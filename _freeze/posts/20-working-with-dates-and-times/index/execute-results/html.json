{
  "hash": "7c725ba17ddb8d1e0bf0986fe9afc264",
  "result": {
    "markdown": "---\ntitle: \"20 - Working with dates and times\"\nauthor:\n  - name: Leonardo Collado Torres\n    url: http://lcolladotor.github.io/\n    affiliations:\n      - id: libd\n        name: Lieber Institute for Brain Development\n        url: https://libd.org/\n      - id: jhsph\n        name: Johns Hopkins Bloomberg School of Public Health Department of Biostatistics\n        url: https://publichealth.jhu.edu/departments/biostatistics\ndescription: \"Introduction to lubridate for dates and times in R\"\ncategories: [module 5, week 6, tidyverse, R, programming, dates and times]\n---\n\n\n*This lecture, as the rest of the course, is adapted from the version [Stephanie C. Hicks](https://www.stephaniehicks.com/) designed and maintained in 2021 and 2022. Check the recent changes to this file through the [GitHub history](https://github.com/lcolladotor/jhustatcomputing2023/commits/main/posts/20-working-with-dates-and-times/index.qmd).*\n\n<!-- Add interesting quote -->\n\n# Pre-lecture materials\n\n### Read ahead\n\n::: callout-note\n## Read ahead\n\n**Before class, you can prepare by reading the following materials:**\n\n1.  <https://r4ds.had.co.nz/dates-and-times>\n:::\n\n### Acknowledgements\n\nMaterial for this lecture was borrowed and adopted from\n\n-   <https://jhu-advdatasci.github.io/2018/lectures/09-dates-times>\n-   <https://r4ds.had.co.nz/dates-and-times>\n\n# Learning objectives\n\n::: callout-note\n# Learning objectives\n\n**At the end of this lesson you will:**\n\n-   Recognize the `Date`, `POSIXct` and `POSIXlt` class types in R to represent dates and times\n-   Learn how to create date and time objects in R using functions from the `lubridate` package\n-   Learn how dealing with time zones can be frustrating ðŸ™€ but hopefully less so after today's lecture ðŸ˜º\n-   Learn how to perform arithmetic operations on dates and times\n-   Learn how plotting systems in R \"know\" about dates and times to appropriately handle axis labels\n:::\n\n# Introduction\n\nIn this lesson, we will **learn how to work with dates and times** in R. These may seem simple as you use them all of the time in your day-to-day life, but the more you work with them, the more complicated they seem to get.\n\n**Dates and times are hard to work with** because they have to reconcile **two physical phenomena**\n\n1.  The rotation of the Earth and its orbit around the sun AND\n2.  A whole raft of geopolitical phenomena including months, time zones, and daylight savings time (DST)\n\nThis lesson will not teach you every last detail about dates and times, but it will give you a solid grounding of **practical skills** that will help you with common data analysis challenges.\n\n::: callout-tip\n### Classes for dates and times in R\n\nR has developed a special representation of dates and times\n\n-   Dates are represented by the `Date` class\n-   Times are represented by the `POSIXct` or the `POSIXlt` class\n:::\n\n::: callout-tip\n### Important point in time\n\n-   Dates are stored internally as the number of days since 1970-01-01\n-   Times are stored internally as the number of seconds since 1970-01-01\n\nIn computing, **Unix time** (also known as Epoch time, Posix time, seconds since the Epoch, Unix timestamp, or UNIX Epoch time) is a system for **describing a point in time**.\n\nIt is the number of seconds that have elapsed since the Unix epoch, excluding leap seconds. The Unix epoch is 00:00:00 UTC on 1 January 1970.\n\nUnix time originally appeared as the system time of Unix, but is now used widely in computing, for example by filesystems; some Python language library functions handle Unix time.\\[4\\]\n\n<https://en.wikipedia.org/wiki/Unix_time>\n:::\n\n## The `lubridate` package\n\nHere, we will focus on the `lubridate` R package, which makes it easier to work with dates and times in R.\n\n::: callout-tip\n### Pro-tip\n\n**Check out the `lubridate` cheat sheet** at <https://lubridate.tidyverse.org>\n:::\n\nA few things to note about it:\n\n-   It largely **replaces the default date/time functions in base R**\n-   It contains **methods for date/time arithmetic**\n-   It **handles time zones**, leap year, leap seconds, etc.\n\n![Artwork by Allison Horst on the dplyr package](https://github.com/allisonhorst/stats-illustrations/raw/main/rstats-artwork/lubridate_ymd.png){preview=\"TRUE\"} \\[**Source**: [Artwork by Allison Horst](https://github.com/allisonhorst/stats-illustrations)\\]\n\n`lubridate` is installed when you install `tidyverse`, but it is not loaded when you load `tidyverse`. Alternatively, you can install it separately.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"lubridate\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"tidyverse\")\nlibrary(\"lubridate\")\n```\n:::\n\n\n# Creating date/times\n\nThere are three types of date/time data that refer to an instant in time:\n\n-   A **date**. Tibbles print this as `<date>`.\n-   A **time** within a day. Tibbles print this as `<time>`.\n-   A **date-time** is a date plus a time: it uniquely identifies an instant in time (typically to the nearest second). Tibbles print this as `<dttm>`. Elsewhere in R these are called `POSIXct`.\n\n::: callout-tip\n### Note\n\nWe will **focus on dates and date-times** as R does not have a native class for storing times.\n\nIf you to work with **only times**, you can use the [`hms` package](https://cran.r-project.org/web/packages/hms/index.html).\n:::\n\nYou should always **use the simplest possible data type** that works for your needs.\n\nThat means if you can use a `date` instead of a `date-time`, you should.\n\n**Date-times** are **substantially more complicated** because of the need to handle time zones, which we will come back to at the end of the lesson.\n\nTo get the current date or date-time you can use `today()` or `now()` from `lubridate`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## lubridate versions\ntoday()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2023-10-02\"\n```\n:::\n\n```{.r .cell-code}\nnow()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2023-10-02 20:28:00 EDT\"\n```\n:::\n\n```{.r .cell-code}\n## base R versions\nbase::Sys.Date()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2023-10-02\"\n```\n:::\n\n```{.r .cell-code}\nbase::Sys.time()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2023-10-02 20:28:00 EDT\"\n```\n:::\n:::\n\n\nOtherwise, there are three ways you are likely to create a date/time:\n\n::: callout-tip\n### Typical ways to create a date/time in R\n\n1.  From a string\n2.  From individual date-time components\n3.  From an existing date/time object\n:::\n\nThey work as follows.\n\n## 1. From a string\n\nDates are of the `Date` class.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- today()\nclass(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Date\"\n```\n:::\n:::\n\n\nDates can be **coerced from a character strings** using some helper functions from `lubridate`. They **automatically work out the format** once you specify the order of the component.\n\nTo use the helper functions, **identify the order in which year, month, and day appear** in your dates, then arrange \"y\", \"m\", and \"d\" in the same order.\n\nThat gives you the name of the `lubridate` function that will parse your date. For example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nymd(\"1970-01-01\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"1970-01-01\"\n```\n:::\n\n```{.r .cell-code}\nymd(\"2017-01-31\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2017-01-31\"\n```\n:::\n\n```{.r .cell-code}\nmdy(\"January 31st, 2017\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2017-01-31\"\n```\n:::\n\n```{.r .cell-code}\ndmy(\"31-Jan-2017\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2017-01-31\"\n```\n:::\n\n```{.r .cell-code}\n## Base R versions\nas.Date(\"1970-01-01\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"1970-01-01\"\n```\n:::\n\n```{.r .cell-code}\n## Quickly becomes more complicated.\n## We quickly need to get familiarized with\n## formats for specifying dates, and that's complicated.\n# ?strptime\nas.Date(\"January 31st, 2017\", \"%B %dst, %Y\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2017-01-31\"\n```\n:::\n\n```{.r .cell-code}\nas.Date(gsub(\"st,\", \"\", \"January 31st, 2017\"), \"%B %d %Y\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2017-01-31\"\n```\n:::\n:::\n\n\n::: callout-tip\n### Pro-tip\n\n-   When reading in data with `read_csv()`, you **may need to read in as character first** and then **convert to date/time**\n-   `Date` objects have their own special `print()` methods that will **always format** as \"YYYY-MM-DD\"\n-   These functions also take unquoted numbers.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nymd(20170131)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2017-01-31\"\n```\n:::\n:::\n\n:::\n\n### Alternate Formulations\n\nDifferent locales have different ways of formatting dates\n\n\n::: {.cell}\n\n```{.r .cell-code}\nymd(\"2016-09-13\") ## International standard\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2016-09-13\"\n```\n:::\n\n```{.r .cell-code}\nymd(\"2016/09/13\") ## Just figure it out\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2016-09-13\"\n```\n:::\n\n```{.r .cell-code}\nmdy(\"09-13-2016\") ## Mostly U.S.\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2016-09-13\"\n```\n:::\n\n```{.r .cell-code}\ndmy(\"13-09-2016\") ## Europe\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2016-09-13\"\n```\n:::\n:::\n\n\nAll of the **above are valid and lead to the exact same object**.\n\nEven if the individual dates are formatted differently, `ymd()` can **usually figure it out**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(\n    \"2016-04-05\",\n    \"2016/05/06\",\n    \"2016,10,4\"\n)\nymd(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2016-04-05\" \"2016-05-06\" \"2016-10-04\"\n```\n:::\n:::\n\n\nCool right?\n\n## 2. From individual date-time components\n\nSometimes the **date components** will come across **multiple columns in a dataset**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"nycflights13\")\n\nflights %>%\n    select(year, month, day)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 336,776 Ã— 3\n    year month   day\n   <int> <int> <int>\n 1  2013     1     1\n 2  2013     1     1\n 3  2013     1     1\n 4  2013     1     1\n 5  2013     1     1\n 6  2013     1     1\n 7  2013     1     1\n 8  2013     1     1\n 9  2013     1     1\n10  2013     1     1\n# â„¹ 336,766 more rows\n```\n:::\n:::\n\n\nTo create a date/time from this sort of input, use\n\n-   `make_date(year, month, day)` for dates, or\n-   `make_datetime(year, month, day, hour, min, sec, tz)` for date-times\n\nWe combine these functions inside of `mutate` to add a new column to our dataset:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights %>%\n    select(year, month, day) %>%\n    mutate(departure = make_date(year, month, day))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 336,776 Ã— 4\n    year month   day departure \n   <int> <int> <int> <date>    \n 1  2013     1     1 2013-01-01\n 2  2013     1     1 2013-01-01\n 3  2013     1     1 2013-01-01\n 4  2013     1     1 2013-01-01\n 5  2013     1     1 2013-01-01\n 6  2013     1     1 2013-01-01\n 7  2013     1     1 2013-01-01\n 8  2013     1     1 2013-01-01\n 9  2013     1     1 2013-01-01\n10  2013     1     1 2013-01-01\n# â„¹ 336,766 more rows\n```\n:::\n:::\n\n\n::: callout-note\n### Questions\n\nThe `flights` also contains a `hour` and `minute` column.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights %>%\n    select(year, month, day, hour, minute)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 336,776 Ã— 5\n    year month   day  hour minute\n   <int> <int> <int> <dbl>  <dbl>\n 1  2013     1     1     5     15\n 2  2013     1     1     5     29\n 3  2013     1     1     5     40\n 4  2013     1     1     5     45\n 5  2013     1     1     6      0\n 6  2013     1     1     5     58\n 7  2013     1     1     6      0\n 8  2013     1     1     6      0\n 9  2013     1     1     6      0\n10  2013     1     1     6      0\n# â„¹ 336,766 more rows\n```\n:::\n:::\n\n\nLet's use `make_datetime()` to create a date-time column called `departure`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# try it yourself\n```\n:::\n\n:::\n\n## 3. From other types\n\nYou may want to **switch** between a `date-time` and a `date`.\n\nThat is the job of `as_datetime()` and `as_date()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntoday()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2023-10-02\"\n```\n:::\n\n```{.r .cell-code}\nas_datetime(today())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2023-10-02 UTC\"\n```\n:::\n\n```{.r .cell-code}\nnow()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2023-10-02 20:28:01 EDT\"\n```\n:::\n\n```{.r .cell-code}\nas_date(now())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2023-10-02\"\n```\n:::\n:::\n\n\n# Date-Times in R\n\n## From a string\n\n`ymd()` and friends create dates.\n\nTo create a `date-time` **from a character string**, add an underscore and one or more of \"h\", \"m\", and \"s\" to the name of the parsing function:\n\nTimes can be coerced from a character string with `ymd_hms()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nymd_hms(\"2017-01-31 20:11:59\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2017-01-31 20:11:59 UTC\"\n```\n:::\n\n```{.r .cell-code}\nmdy_hm(\"01/31/2017 08:01\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2017-01-31 08:01:00 UTC\"\n```\n:::\n:::\n\n\nYou can also force the creation of a date-time from a date by supplying a timezone:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nymd_hms(\"2016-09-13 14:00:00\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2016-09-13 14:00:00 UTC\"\n```\n:::\n\n```{.r .cell-code}\nymd_hms(\"2016-09-13 14:00:00\", tz = \"America/New_York\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2016-09-13 14:00:00 EDT\"\n```\n:::\n\n```{.r .cell-code}\nymd_hms(\"2016-09-13 14:00:00\", tz = \"\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2016-09-13 14:00:00 EDT\"\n```\n:::\n:::\n\n\n## `POSIXct` or the `POSIXlt` class\n\nLet's get into some hairy details about date-times. Date-times are represented using the `POSIXct` or the `POSIXlt` class in R. What are these things?\n\n### `POSIXct`\n\n`POSIXct` is just a very large integer under the hood. It is a useful class when you want to store times in something like a data frame.\n\nTechnically, the `POSIXct` class represents the number of **seconds** since 1 January 1970. (In case you were wondering, \"POSIXct\" stands for \"Portable Operating System Interface\", calendar time.)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- ymd_hm(\"1970-01-01 01:00\")\nclass(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"POSIXct\" \"POSIXt\" \n```\n:::\n\n```{.r .cell-code}\nunclass(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3600\nattr(,\"tzone\")\n[1] \"UTC\"\n```\n:::\n\n```{.r .cell-code}\ntypeof(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"double\"\n```\n:::\n\n```{.r .cell-code}\nattributes(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$class\n[1] \"POSIXct\" \"POSIXt\" \n\n$tzone\n[1] \"UTC\"\n```\n:::\n:::\n\n\n### `POSIXlt`\n\n`POSIXlt` is a `list` underneath and it stores a bunch of other useful information like the day of the week, day of the year, month, day of the month\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- as.POSIXlt(x)\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"1970-01-01 01:00:00 UTC\"\n```\n:::\n\n```{.r .cell-code}\ntypeof(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"list\"\n```\n:::\n\n```{.r .cell-code}\nattributes(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$names\n [1] \"sec\"    \"min\"    \"hour\"   \"mday\"   \"mon\"    \"year\"   \"wday\"   \"yday\"  \n [9] \"isdst\"  \"zone\"   \"gmtoff\"\n\n$class\n[1] \"POSIXlt\" \"POSIXt\" \n\n$tzone\n[1] \"UTC\"\n\n$balanced\n[1] TRUE\n```\n:::\n:::\n\n\n::: callout-tip\n### Pro-tip\n\n`POSIXlt`s are **rare** inside the tidyverse. They do crop up in base R, because they are needed to extract specific components of a date, like the year or month.\n\nSince `lubridate` provides helpers for you to do this instead, you do not really need them imho.\n\n`POSIXct`'s are always easier to work with, so if you find you have a `POSIXlt`, you should always convert it to a regular data time `lubridate::as_datetime()`.\n:::\n\n# Time Zones!\n\nTime zones were created to **make your data analyses more difficult as a data analyst**.\n\nHere are a few fun things to think about:\n\n-   `ymd_hms()` function will by **default use Coordinated Universal Time (UTC) as the time zone**. UTC is the primary time standard by which the world regulates clocks and time.\n\nYou can go to Wikipedia to find the [list of time zones](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones)\n\n-   Specifying `tz = \"\"` in one of the `ymd()` and friends functions will use the local time zone\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- ymd_hm(\"1970-01-01 01:00\", tz = \"\")\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"1970-01-01 01:00:00 EST\"\n```\n:::\n\n```{.r .cell-code}\nattributes(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$class\n[1] \"POSIXct\" \"POSIXt\" \n\n$tzone\n[1] \"\"\n```\n:::\n:::\n\n\n::: callout-tip\n### Pro-tip\n\nThe `tzone` attribute is optional. It **controls how the time is printed**, not what absolute time it refers to.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nattr(x, \"tzone\") <- \"US/Pacific\"\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"1969-12-31 22:00:00 PST\"\n```\n:::\n\n```{.r .cell-code}\nattr(x, \"tzone\") <- \"US/Eastern\"\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"1970-01-01 01:00:00 EST\"\n```\n:::\n:::\n\n:::\n\nA few other fun things to think about related to time zones:\n\n-   Almost always better to specify time zone when possible to avoid ambiguity\n\n-   Daylight savings time (DST)\n\n-   Some states are in two time zones\n\n-   Southern hemisphere is opposite\n\n# Operations on Dates and Times\n\n## Arithmetic\n\nYou **can add and subtract** dates and times.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- ymd(\"2012-01-01\", tz = \"\") ## Midnight\ny <- dmy_hms(\"9 Jan 2011 11:34:21\", tz = \"\")\nx - y ## this works\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTime difference of 356.5178 days\n```\n:::\n:::\n\n\nYou can do comparisons too (i.e. `>`, `<`, and `==`)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx < y ## this works\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nx > y ## this works\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nx == y ## this works\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nx + y ## what??? why does this not work?\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in `+.POSIXt`(x, y): binary '+' is not defined for \"POSIXt\" objects\n```\n:::\n:::\n\n\n::: callout-tip\n### Note\n\nThe class of `x` is `POSIXct`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"POSIXct\" \"POSIXt\" \n```\n:::\n:::\n\n\n`POSIXct` objects are a measure of seconds from an origin, usually the UNIX epoch (1st Jan 1970).\n\nJust add the requisite number of seconds to the object:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx + 3 * 60 * 60 # add 3 hours\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2012-01-01 03:00:00 EST\"\n```\n:::\n:::\n\n:::\n\nSame goes for days. For example, you can just keep the date portion using `date()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- date(y)\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2011-01-09\"\n```\n:::\n:::\n\n\nAnd then add a number to the date (in this case 1 day)\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny + 1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2011-01-10\"\n```\n:::\n:::\n\n\nCool eh?\n\n## Leaps and Bounds\n\nEven keeps track of leap years, leap seconds, daylight savings, and time zones.\n\nLeap years\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- ymd(\"2012-03-01\")\ny <- ymd(\"2012-02-28\")\nx - y\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTime difference of 2 days\n```\n:::\n:::\n\n\nNot a leap year\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- ymd(\"2013-03-01\")\ny <- ymd(\"2013-02-28\")\nx - y\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTime difference of 1 days\n```\n:::\n:::\n\n\nBUT beware of time zones!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- ymd_hms(\"2012-10-25 01:00:00\", tz = \"\")\ny <- ymd_hms(\"2012-10-25 05:00:00\", tz = \"GMT\")\ny - x\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTime difference of 0 secs\n```\n:::\n:::\n\n\nThere are also things called [**leap seconds**](https://en.wikipedia.org/wiki/Leap_second).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n.leap.seconds\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"1972-07-01 GMT\" \"1973-01-01 GMT\" \"1974-01-01 GMT\" \"1975-01-01 GMT\"\n [5] \"1976-01-01 GMT\" \"1977-01-01 GMT\" \"1978-01-01 GMT\" \"1979-01-01 GMT\"\n [9] \"1980-01-01 GMT\" \"1981-07-01 GMT\" \"1982-07-01 GMT\" \"1983-07-01 GMT\"\n[13] \"1985-07-01 GMT\" \"1988-01-01 GMT\" \"1990-01-01 GMT\" \"1991-01-01 GMT\"\n[17] \"1992-07-01 GMT\" \"1993-07-01 GMT\" \"1994-07-01 GMT\" \"1996-01-01 GMT\"\n[21] \"1997-07-01 GMT\" \"1999-01-01 GMT\" \"2006-01-01 GMT\" \"2009-01-01 GMT\"\n[25] \"2012-07-01 GMT\" \"2015-07-01 GMT\" \"2017-01-01 GMT\"\n```\n:::\n:::\n\n\n# Extracting Elements of Dates/Times\n\nThere are a set of helper functions in `lubridate` that can extract sub-elements of dates/times\n\n## Date Elements\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- ymd_hms(c(\n    \"2012-10-25 01:13:46\",\n    \"2015-04-23 15:11:23\"\n), tz = \"\")\nyear(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2012 2015\n```\n:::\n\n```{.r .cell-code}\nmonth(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 10  4\n```\n:::\n\n```{.r .cell-code}\nday(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 25 23\n```\n:::\n\n```{.r .cell-code}\nweekdays(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Thursday\" \"Thursday\"\n```\n:::\n:::\n\n\n## Time Elements\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- ymd_hms(c(\n    \"2012-10-25 01:13:46\",\n    \"2015-04-23 15:11:23\"\n), tz = \"\")\nminute(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 13 11\n```\n:::\n\n```{.r .cell-code}\nsecond(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 46 23\n```\n:::\n\n```{.r .cell-code}\nhour(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  1 15\n```\n:::\n\n```{.r .cell-code}\nweek(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 43 17\n```\n:::\n:::\n\n\n# Visualizing Dates\n\n## Reading in the Data\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(here)\nlibrary(readr)\nstorm <- read_csv(here(\"data\", \"storms_2004.csv.gz\"), progress = FALSE)\nstorm\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 52,409 Ã— 51\n   BEGIN_YEARMONTH BEGIN_DAY BEGIN_TIME END_YEARMONTH END_DAY END_TIME\n             <dbl>     <dbl>      <dbl>         <dbl>   <dbl>    <dbl>\n 1          200412        29       1800        200412      30     1200\n 2          200412        29       1800        200412      30     1200\n 3          200412         8       1800        200412       8     1800\n 4          200412        19       1500        200412      19     1700\n 5          200412        14        600        200412      14      800\n 6          200412        21        400        200412      21      800\n 7          200412        21        400        200412      21      800\n 8          200412        26       1500        200412      27      800\n 9          200412        26       1500        200412      27      800\n10          200412        11        800        200412      11     1300\n# â„¹ 52,399 more rows\n# â„¹ 45 more variables: EPISODE_ID <dbl>, EVENT_ID <dbl>, STATE <chr>,\n#   STATE_FIPS <dbl>, YEAR <dbl>, MONTH_NAME <chr>, EVENT_TYPE <chr>,\n#   CZ_TYPE <chr>, CZ_FIPS <dbl>, CZ_NAME <chr>, WFO <chr>,\n#   BEGIN_DATE_TIME <chr>, CZ_TIMEZONE <chr>, END_DATE_TIME <chr>,\n#   INJURIES_DIRECT <dbl>, INJURIES_INDIRECT <dbl>, DEATHS_DIRECT <dbl>,\n#   DEATHS_INDIRECT <dbl>, DAMAGE_PROPERTY <chr>, DAMAGE_CROPS <chr>, â€¦\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(storm)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"BEGIN_YEARMONTH\"    \"BEGIN_DAY\"          \"BEGIN_TIME\"        \n [4] \"END_YEARMONTH\"      \"END_DAY\"            \"END_TIME\"          \n [7] \"EPISODE_ID\"         \"EVENT_ID\"           \"STATE\"             \n[10] \"STATE_FIPS\"         \"YEAR\"               \"MONTH_NAME\"        \n[13] \"EVENT_TYPE\"         \"CZ_TYPE\"            \"CZ_FIPS\"           \n[16] \"CZ_NAME\"            \"WFO\"                \"BEGIN_DATE_TIME\"   \n[19] \"CZ_TIMEZONE\"        \"END_DATE_TIME\"      \"INJURIES_DIRECT\"   \n[22] \"INJURIES_INDIRECT\"  \"DEATHS_DIRECT\"      \"DEATHS_INDIRECT\"   \n[25] \"DAMAGE_PROPERTY\"    \"DAMAGE_CROPS\"       \"SOURCE\"            \n[28] \"MAGNITUDE\"          \"MAGNITUDE_TYPE\"     \"FLOOD_CAUSE\"       \n[31] \"CATEGORY\"           \"TOR_F_SCALE\"        \"TOR_LENGTH\"        \n[34] \"TOR_WIDTH\"          \"TOR_OTHER_WFO\"      \"TOR_OTHER_CZ_STATE\"\n[37] \"TOR_OTHER_CZ_FIPS\"  \"TOR_OTHER_CZ_NAME\"  \"BEGIN_RANGE\"       \n[40] \"BEGIN_AZIMUTH\"      \"BEGIN_LOCATION\"     \"END_RANGE\"         \n[43] \"END_AZIMUTH\"        \"END_LOCATION\"       \"BEGIN_LAT\"         \n[46] \"BEGIN_LON\"          \"END_LAT\"            \"END_LON\"           \n[49] \"EPISODE_NARRATIVE\"  \"EVENT_NARRATIVE\"    \"DATA_SOURCE\"       \n```\n:::\n:::\n\n\n::: callout-note\n### Questions\n\nLet's take a look at the `BEGIN_DATE_TIME`, `EVENT_TYPE`, and `DEATHS_DIRECT` variables from the `storm` dataset.\n\nTasks:\n\n1.  Create a subset of the `storm` dataset with only the four columns above.\n2.  Create a new column called `begin` that contains the `BEGIN_DATE_TIME` that has been converted to a date/time R object.\n3.  Rename the `EVENT_TYPE` column as `type`.\n4.  Rename the `DEATHS_DIRECT` column as `deaths`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n\n# try it yourself\n```\n:::\n\n:::\n\nNext, we do some wrangling to create a `storm_sub` data frame (code chunk set to `echo=FALSE` for the purposes of the lecture, but code is in the R Markdown).\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nstorm_sub\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 52,409 Ã— 3\n   begin               type             deaths\n   <dttm>              <chr>             <dbl>\n 1 2004-12-29 18:00:00 Heavy Snow            0\n 2 2004-12-29 18:00:00 Heavy Snow            0\n 3 2004-12-08 18:00:00 Winter Storm          0\n 4 2004-12-19 15:00:00 High Wind             0\n 5 2004-12-14 06:00:00 Winter Weather        0\n 6 2004-12-21 04:00:00 Winter Storm          0\n 7 2004-12-21 04:00:00 Winter Storm          0\n 8 2004-12-26 15:00:00 Winter Storm          0\n 9 2004-12-26 15:00:00 Winter Storm          0\n10 2004-12-11 08:00:00 Storm Surge/Tide      0\n# â„¹ 52,399 more rows\n```\n:::\n:::\n\n\n## Histograms of Dates/Times\n\nWe can make a histogram of the dates/times to get a sense of when storm events occur.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"ggplot2\")\nstorm_sub %>%\n    ggplot(aes(x = begin)) +\n    geom_histogram(bins = 20) +\n    theme_bw()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-37-1.png){width=672}\n:::\n:::\n\n\nWe can group by event type too.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nstorm_sub %>%\n    ggplot(aes(x = begin)) +\n    facet_wrap(~type) +\n    geom_histogram(bins = 20) +\n    theme_bw() +\n    theme(axis.text.x.bottom = element_text(angle = 90))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-38-1.png){width=1152}\n:::\n:::\n\n\n## Scatterplots of Dates/Times\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstorm_sub %>%\n    ggplot(aes(x = begin, y = deaths)) +\n    geom_point()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-39-1.png){width=672}\n:::\n:::\n\n\nIf we focus on a single month, the x-axis adapts.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstorm_sub %>%\n    filter(month(begin) == 6) %>%\n    ggplot(aes(begin, deaths)) +\n    geom_point()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-40-1.png){width=672}\n:::\n:::\n\n\nSimilarly, we can focus on a single day.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstorm_sub %>%\n    filter(month(begin) == 6, day(begin) == 16) %>%\n    ggplot(aes(begin, deaths)) +\n    geom_point()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-41-1.png){width=672}\n:::\n:::\n\n\n# Summary\n\n-   Dates and times have special classes in R that allow for numerical and statistical calculations\n\n-   Dates use the `Date` class\n\n-   Date-Times (and Times) use the `POSIXct` and `POSIXlt` class\n\n-   Character strings can be coerced to Date/Time classes using the `ymd()` and `ymd_hms()` functions and friends.\n\n-   The `lubridate` package is essential for manipulating date/time data\n\n-   Both `plot` and `ggplot` \"know\" about dates and times and will handle axis labels appropriately.\n\n# Post-lecture materials\n\n### Final Questions\n\nHere are some post-lecture questions to help you think about the material discussed.\n\n::: callout-note\n### Questions\n\n1.  What happens if you parse a string that contains invalid dates?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nymd(c(\"2010-10-10\", \"bananas\"))\n\n## Compare against base R's behavior:\nas.Date(c(\"2010-10-10\", \"bananas\"))\n```\n:::\n\n\n2.  What does the `tzone` argument to `today()` do? Why is it important?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nunclass(today())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 19632\n```\n:::\n:::\n\n\n3.  Use the appropriate `lubridate` function to parse each of the following dates:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd1 <- \"January 1, 2010\"\nd2 <- \"2015-Mar-07\"\nd3 <- \"06-Jun-2017\"\nd4 <- c(\"August 19 (2015)\", \"July 1 (2015)\")\nd5 <- \"12/30/14\" # Dec 30, 20\n```\n:::\n\n\n4.  Using the `flights` dataset, how does the distribution of flight times within a day change over the course of the year?\n\n5.  Compare `dep_time`, `sched_dep_time` and `dep_delay`. Are they consistent? Explain your findings.\n:::\n\n### Additional Resources\n\n::: callout-tip\n-   <https://lubridate.tidyverse.org>\n-   `lubridate` cheat sheet: <https://rawgit.com/rstudio/cheatsheets/master/lubridate.pdf>\n-   <https://jhu-advdatasci.github.io/2018/lectures/09-dates-times>\n-   <https://r4ds.had.co.nz/dates-and-times>\n:::\n\n# R session information\n\n\n::: {.cell}\n\n```{.r .cell-code}\noptions(width = 120)\nsessioninfo::session_info()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nâ”€ Session info â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n setting  value\n version  R version 4.3.1 (2023-06-16)\n os       macOS Ventura 13.6\n system   aarch64, darwin20\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       America/New_York\n date     2023-10-02\n pandoc   3.1.5 @ /opt/homebrew/bin/ (via rmarkdown)\n\nâ”€ Packages â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n package      * version date (UTC) lib source\n bit            4.0.5   2022-11-15 [1] CRAN (R 4.3.0)\n bit64          4.0.5   2020-08-30 [1] CRAN (R 4.3.0)\n cli            3.6.1   2023-03-23 [1] CRAN (R 4.3.0)\n colorout       1.3-0   2023-09-28 [1] Github (jalvesaq/colorout@8384882)\n colorspace     2.1-0   2023-01-23 [1] CRAN (R 4.3.0)\n crayon         1.5.2   2022-09-29 [1] CRAN (R 4.3.0)\n digest         0.6.33  2023-07-07 [1] CRAN (R 4.3.0)\n dplyr        * 1.1.3   2023-09-03 [1] CRAN (R 4.3.0)\n emojifont      0.5.5   2021-04-20 [1] CRAN (R 4.3.0)\n evaluate       0.21    2023-05-05 [1] CRAN (R 4.3.0)\n fansi          1.0.4   2023-01-22 [1] CRAN (R 4.3.0)\n farver         2.1.1   2022-07-06 [1] CRAN (R 4.3.0)\n fastmap        1.1.1   2023-02-24 [1] CRAN (R 4.3.0)\n forcats      * 1.0.0   2023-01-29 [1] CRAN (R 4.3.0)\n generics       0.1.3   2022-07-05 [1] CRAN (R 4.3.0)\n ggplot2      * 3.4.3   2023-08-14 [1] CRAN (R 4.3.0)\n glue           1.6.2   2022-02-24 [1] CRAN (R 4.3.0)\n gtable         0.3.4   2023-08-21 [1] CRAN (R 4.3.0)\n here         * 1.0.1   2020-12-13 [1] CRAN (R 4.3.0)\n hms            1.1.3   2023-03-21 [1] CRAN (R 4.3.0)\n htmltools      0.5.6   2023-08-10 [1] CRAN (R 4.3.0)\n htmlwidgets    1.6.2   2023-03-17 [1] CRAN (R 4.3.0)\n jsonlite       1.8.7   2023-06-29 [1] CRAN (R 4.3.0)\n knitr          1.44    2023-09-11 [1] CRAN (R 4.3.0)\n labeling       0.4.3   2023-08-29 [1] CRAN (R 4.3.0)\n lifecycle      1.0.3   2022-10-07 [1] CRAN (R 4.3.0)\n lubridate    * 1.9.2   2023-02-10 [1] CRAN (R 4.3.0)\n magrittr       2.0.3   2022-03-30 [1] CRAN (R 4.3.0)\n munsell        0.5.0   2018-06-12 [1] CRAN (R 4.3.0)\n nycflights13 * 1.0.2   2021-04-12 [1] CRAN (R 4.3.0)\n pillar         1.9.0   2023-03-22 [1] CRAN (R 4.3.0)\n pkgconfig      2.0.3   2019-09-22 [1] CRAN (R 4.3.0)\n proto          1.0.0   2016-10-29 [1] CRAN (R 4.3.0)\n purrr        * 1.0.2   2023-08-10 [1] CRAN (R 4.3.0)\n R6             2.5.1   2021-08-19 [1] CRAN (R 4.3.0)\n readr        * 2.1.4   2023-02-10 [1] CRAN (R 4.3.0)\n rlang          1.1.1   2023-04-28 [1] CRAN (R 4.3.0)\n rmarkdown      2.24    2023-08-14 [1] CRAN (R 4.3.1)\n rprojroot      2.0.3   2022-04-02 [1] CRAN (R 4.3.0)\n rstudioapi     0.15.0  2023-07-07 [1] CRAN (R 4.3.0)\n scales         1.2.1   2022-08-20 [1] CRAN (R 4.3.0)\n sessioninfo    1.2.2   2021-12-06 [1] CRAN (R 4.3.0)\n showtext       0.9-6   2023-05-03 [1] CRAN (R 4.3.0)\n showtextdb     3.0     2020-06-04 [1] CRAN (R 4.3.0)\n stringi        1.7.12  2023-01-11 [1] CRAN (R 4.3.0)\n stringr      * 1.5.0   2022-12-02 [1] CRAN (R 4.3.0)\n sysfonts       0.8.8   2022-03-13 [1] CRAN (R 4.3.0)\n tibble       * 3.2.1   2023-03-20 [1] CRAN (R 4.3.0)\n tidyr        * 1.3.0   2023-01-24 [1] CRAN (R 4.3.0)\n tidyselect     1.2.0   2022-10-10 [1] CRAN (R 4.3.0)\n tidyverse    * 2.0.0   2023-02-22 [1] CRAN (R 4.3.0)\n timechange     0.2.0   2023-01-11 [1] CRAN (R 4.3.0)\n tzdb           0.4.0   2023-05-12 [1] CRAN (R 4.3.0)\n utf8           1.2.3   2023-01-31 [1] CRAN (R 4.3.0)\n vctrs          0.6.3   2023-06-14 [1] CRAN (R 4.3.0)\n vroom          1.6.3   2023-04-28 [1] CRAN (R 4.3.0)\n withr          2.5.0   2022-03-03 [1] CRAN (R 4.3.0)\n xfun           0.40    2023-08-09 [1] CRAN (R 4.3.0)\n yaml           2.3.7   2023-01-23 [1] CRAN (R 4.3.0)\n\n [1] /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/library\n\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n```\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}