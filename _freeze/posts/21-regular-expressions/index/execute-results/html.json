{
  "hash": "e2882097b166b6adf6874f45d779ab8c",
  "result": {
    "markdown": "---\ntitle: \"21 - Regular expressions\"\nauthor:\n  - name: Leonardo Collado Torres\n    url: http://lcolladotor.github.io/\n    affiliations:\n      - id: libd\n        name: Lieber Institute for Brain Development\n        url: https://libd.org/\n      - id: jhsph\n        name: Johns Hopkins Bloomberg School of Public Health Department of Biostatistics\n        url: https://publichealth.jhu.edu/departments/biostatistics\ndescription: \"Introduction to working with character strings and regular expressions in R\"\ncategories: [module 5, week 6, tidyverse, R, programming, strings and regex]\n---\n\n\n*This lecture, as the rest of the course, is adapted from the version [Stephanie C. Hicks](https://www.stephaniehicks.com/) designed and maintained in 2021 and 2022. Check the recent changes to this file through the [GitHub history](https://github.com/lcolladotor/jhustatcomputing/commits/main/posts/21-regular-expressions/index.qmd).*\n\n<!-- Add interesting quote -->\n\n# Pre-lecture materials\n\n### Read ahead\n\n::: callout-note\n## Read ahead\n\n**Before class, you can prepare by reading the following materials:**\n\n1.  <https://r4ds.had.co.nz/strings>\n:::\n\n### Acknowledgements\n\nMaterial for this lecture was borrowed and adopted from\n\n-   <https://rdpeng.github.io/Biostat776/lecture-regular-expressions>\n-   <https://r4ds.had.co.nz/strings>\n\n# Learning objectives\n\n::: callout-note\n# Learning objectives\n\n**At the end of this lesson you will:**\n\n-   Understand what is a 'regular expression' and how to create one\n-   Learn the basics of searching for patterns in character strings in base R and the `stringr` R package in the `tidyverse`\n-   Use the built in character sets to search for patterns in strings including `\"\\n\"`, `\"\\t\"`, `\"\\w\"`, `\"\\d\"`, and `\"\\s\"`\n:::\n\n# Introduction\n\n## regex basics\n\nA **regular expression** (also known as a \"regex\" or \"regexp\") is a concise language for describing patterns in character strings.\n\nRegex could be **patterns that could be contained within another string**.\n\n::: callout-tip\n### Example\n\nFor example, if we wanted to search for the pattern \"ai\" in the character string \"The rain in Spain\", we see it appears twice!\n\n\"The r**ai**n in Sp**ai**n\"\n:::\n\nGenerally, a regular expression can be used for e.g.\n\n-   **searching for a pattern or string** within another string (e.g searching for the string \"a\" in the string \"Maryland\")\n-   **replacing one part of a string** with another string (e.g replacing the string \"t\" with \"p\" in the string \"hot\" where you are changing the string \"hot\" to \"hop\")\n\nIf you have never worked with regular expressions, it can seem like maybe a baby hit the keys on your keyboard (complete gibberish), but it will slowly make sense once you learn the syntax.\n\nSoon you will **be able create incredibly powerful regular expressions** in your day-to-day work.\n\n## string basics\n\nIn R, you can **create (character) strings** with either single quotes (`'hello!'`) or double quotes (`\"hello!\"`) -- no difference (not true for other languages!).\n\nI **recommend using the double quotes**, unless you want to create a string with multiple `\"`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstring1 <- \"This is a string\"\nstring2 <- 'If I want to include a \"quote\" inside a string, I use single quotes'\n```\n:::\n\n\n::: callout-tip\n### Pro-tip\n\nStrings can be tricky when executing them. If you forget to close a quote, you'll see `+`\n\n``` r\n> \"This is a string without a closing quote\n+ \n+ \n+ HELP I'M STUCK\n```\n\nIf this happen to you, take a deep breath, press `Escape` and try again.\n:::\n\nMultiple strings are often stored in a character vector, which you can create with `c()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(\"one\", \"two\", \"three\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"one\"   \"two\"   \"three\"\n```\n:::\n:::\n\n\n# `grepl()`\n\nOne of the **most basic functions in R that uses regular expressions** is the `grepl(pattern, x)` function, which takes **two arguments** and **returns a logical**:\n\n1.  A regular expression (`pattern`)\n2.  A string to be searched (`x`)\n\nIn case you are curious, \"grepl\" literally translates to \"grep logical\".\n\nIf the string (`x`) contains the specified regular expression (`pattern`), then `grepl()` will return `TRUE`, otherwise it will return `FALSE`.\n\nLet's take a look at one example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nregular_expression <- \"a\"\nstring_to_search <- \"Maryland\"\n\ngrepl(pattern = regular_expression, x = string_to_search)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\nIn the example above, we specify the regular expression `\"a\"` and store it in a variable called `regular_expression`.\n\n::: callout-tip\n### Note\n\n**Remember** that regular expressions are just strings!\n:::\n\nWe also store the string `\"Maryland\"` in a variable called `string_to_search`.\n\nThe regular expression `\"a\"` represents a single occurrence of the character `\"a\"`. Since `\"a\"` is contained within `\"Maryland\"`, `grepl()` returns the value `TRUE`.\n\n::: callout-tip\n### Example\n\nLet's try another simple example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nregular_expression <- \"u\"\nstring_to_search <- \"Maryland\"\n\ngrepl(pattern = regular_expression, x = string_to_search)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n\nThe regular expression `\"u\"` represents a single occurrence of the character `\"u\"`, which is not a sub-string of `\"Maryland\"`, therefore `grepl()` returns the value `FALSE`.\n:::\n\nRegular expressions can be much longer than single characters. You could for example search for smaller strings inside of a larger string:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrepl(\"land\", \"Maryland\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\ngrepl(\"ryla\", \"Maryland\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\ngrepl(\"Marly\", \"Maryland\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\ngrepl(\"dany\", \"Maryland\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n\nSince `\"land\"` and `\"ryla\"` are sub-strings of `\"Maryland\"`, `grepl()` returns `TRUE`, however when a regular expression like `\"Marly\"` or `\"dany\"` is searched `grepl()` returns `FALSE` because neither are sub-strings of `\"Maryland\"`.\n\n::: callout-tip\n### Introduce the US states dataset `state.name`\n\nThere is a dataset that comes with R called `state.name` which is a vector of strings, one for each state in the United States of America.\n\nWe are going to use this vector in several of the following examples.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(state.name)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Alabama\"    \"Alaska\"     \"Arizona\"    \"Arkansas\"   \"California\"\n[6] \"Colorado\"  \n```\n:::\n\n```{.r .cell-code}\nlength(state.name)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 50\n```\n:::\n:::\n\n:::\n\nNext, we will build a **regular expression for identifying several strings in this vector** of character strings, specifically a regular expression that will match names of states that both start and end with a vowel.\n\nThe state name could start and end with any vowel, so we will not be able to match exact sub-strings like in the previous examples. Thankfully we can use **metacharacters** to look for vowels and other parts of strings.\n\n## metacharacters\n\nThe first metacharacter that we will discuss is `\".\"`.\n\nThe metacharacter that only consists of a period **represents any character other than a new line** (we will discuss new lines soon).\n\n::: callout-tip\n### Example\n\nLet's take a look at some examples using the period regex:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrepl(\".\", \"Maryland\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\ngrepl(\".\", \"*&2[0+,%<@#~|}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\ngrepl(\".\", \"\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n:::\n\nAs you can see the **period metacharacter is very liberal**.\n\nThis metacharacter is **most useful when you do not care about a set of characters** in a regular expression.\n\n::: callout-tip\n### Example\n\nHere is another example\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrepl(\"a.b\", c(\"aaa\", \"aab\", \"abb\", \"acadb\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE  TRUE  TRUE  TRUE\n```\n:::\n:::\n\n\nIn the case above, `grepl()` returns `TRUE` for all strings that contain an `a` followed by any other character followed by a `b`.\n:::\n\n## repetition\n\nYou can specify a regular expression that **contains a certain number of characters or metacharacters** using the **enumeration metacharacters** (or sometimes called **quantifiers**).\n\n-   `+`: indicates that **one or more of the preceding expression** should be present (or matches at least 1 time)\n-   `*`: indicates that **zero or more of the preceding expression** is present (or matches at least 0 times)\n-   `?`: indicates that **zero or 1 of the preceding expression is not present or present at most 1 time** (or matches between 0 and 1 times)\n\n::: callout-tip\n### Example\n\nLet's take a look at some examples using these metacharacters:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Does \"Maryland\" contain one or more of \"a\" ?\ngrepl(\"a+\", \"Maryland\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\n# Does \"Maryland\" contain one or more of \"x\" ?\ngrepl(\"x+\", \"Maryland\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\n# Does \"Maryland\" contain zero or more of \"x\" ?\ngrepl(\"x*\", \"Maryland\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n:::\n\nIf you want to do more than one character, you need to wrap it in `()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Does \"Maryland\" contain zero or more of \"x\" ?\ngrepl(\"(xx)*\", \"Maryland\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n::: callout-note\n### Question\n\nLet's practice a few out together. Make the following regular expressions for the character string \"spookyhalloween\":\n\n1.  Does \"zz\" appear 1 or more times?\n2.  Does \"ee\" appear 1 or more times?\n3.  Does \"oo\" appear 0 or more times?\n4.  Does \"ii\" appear 0 or more times?\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## try it out\n```\n:::\n\n:::\n\nYou can also **specify exact numbers of expressions** using curly brackets `{}`.\n\n-   `{n}`: exactly n\n-   `{n,}`: n or more\n-   `{,m}`: at most m\n-   `{n,m}`: between n and m\n\nFor example `\"a{5}\"` specifies \"a exactly five times\", `\"a{2,5}\"` specifies \"a between 2 and 5 times,\" and `\"a{2,}\"` specifies \"a at least 2 times.\" Let's take a look at some examples:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Does \"Mississippi\" contain exactly 2 adjacent \"s\" ?\ngrepl(\"s{2}\", \"Mississippi\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\n# This is equivalent to the expression above:\ngrepl(\"ss\", \"Mississippi\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\n# Does \"Mississippi\" contain between 1 and 3 adjacent \"s\" ?\ngrepl(\"s{1,3}\", \"Mississippi\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\n# Does \"Mississippi\" contain between 2 and 3 adjacent \"i\" ?\ngrepl(\"i{2,3}\", \"Mississippi\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\n# Does \"Mississippi\" contain between 2 adjacent \"iss\" ?\ngrepl(\"(iss){2}\", \"Mississippi\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\n# Does \"Mississippi\" contain between 2 adjacent \"ss\" ?\ngrepl(\"(ss){2}\", \"Mississippi\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\n# Does \"Mississippi\" contain the pattern of an \"i\" followed by\n# 2 of any character, with that pattern repeated three times adjacently?\ngrepl(\"(i.{2}){3}\", \"Mississippi\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n::: callout-note\n### Question\n\nLet's practice a few out together. Make the following regular expressions for the character string \"spookyspookyhalloweenspookyspookyhalloween\":\n\n1.  Search for \"spooky\" exactly 2 times. What about 3 times?\n2.  Search for \"spooky\" exactly 2 times followed by any character of length 9 (i.e. \"halloween\").\n3.  Same search as above, but search for that twice in a row.\n4.  Same search as above, but search for that three times in a row.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## try it out\n```\n:::\n\n:::\n\n## capture group\n\nIn the examples above, I used parentheses `()` to create a **capturing group**. A capturing group allows you to use quantifiers on other regular expressions.\n\nIn the \"Mississippi\" example, I first created the regex `\"i.{2}\"` which matches `i` followed by any two characters (\"iss\" or \"ipp\"). Then, I used a capture group to wrap that regex, and to specify exactly three adjacent occurrences of that regex.\n\nYou can specify **sets of characters** (or character sets or character classes) with regular expressions, some of which come built in, but you can build your own **character sets** too.\n\nMore on character sets next.\n\n## character sets\n\nFirst, we will discuss the built in **character sets**:\n\n-   words (`\"\\\\w\"`) = **Words** specify **any letter, digit, or a underscore**\n-   digits (`\"\\\\d\"`) = **Digits** specify the **digits 0 through 9**\n-   whitespace characters (`\"\\\\s\"`) = **Whitespace** specifies **line breaks, tabs, or spaces**\n\nEach of these character sets have their own **compliments**:\n\n-   not words (`\"\\\\W\"`)\n-   not digits (`\"\\\\D\"`)\n-   not whitespace characters (`\"\\\\S\"`)\n\nEach specifies all of the characters not included in their corresponding character sets.\n\n::: callout-tip\n### Interesting fact\n\nTechnically, you are using the a character set `\"\\d\"` or `\"\\s\"` (with only one black slash), but because you are using this character set in a string, you need the second `\\` to escape the string. So you will type `\"\\\\d\"` or `\"\\\\s\"`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\"\\\\d\"\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"\\\\d\"\n```\n:::\n:::\n\n\nSo for example, to include a literal single or double quote in a string you can use `\\` to \"escape\" the string and being able to include a single or double quote:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndouble_quote <- \"\\\"\"\ndouble_quote\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"\\\"\"\n```\n:::\n\n```{.r .cell-code}\nsingle_quote <- \"'\"\nsingle_quote\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"'\"\n```\n:::\n:::\n\n\nThat means if you want to include a literal backslash, you will need to double it up: `\"\\\\\"`.\n:::\n\nIn fact, putting **two backslashes before any punctuation mark that is also a metacharacter** indicates that you are **looking for the symbol and not the metacharacter meaning**.\n\nFor example `\"\\\\.\"` indicates you are trying to match a period in a string. Let's take a look at a few examples:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrepl(\"\\\\+\", \"tragedy + time = humor\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\ngrepl(\"\\\\.\", \"https://publichealth.jhu.edu\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n::: callout-tip\n### Beware\n\nThe printed representation of a string is not the same as string itself, because the printed representation shows the escapes. To see the raw contents of the string, use `writeLines()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(\"\\'\", \"\\\"\", \"\\\\\")\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"'\"  \"\\\"\" \"\\\\\"\n```\n:::\n\n```{.r .cell-code}\nwriteLines(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n'\n\"\n\\\n```\n:::\n:::\n\n:::\n\nThere are a handful of **other special characters**. The most common are\n\n-   `\"\\n\"`: newline\n-   `\"\\t\"`: tab,\n\nbut you can see the complete list by requesting help (run the following in the console and a help file will appear:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n?\"'\"\n```\n:::\n\n\nYou will also sometimes see strings like \"\\u00b5\", this is a way of writing non-English characters that works on all platforms:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(\"\\\\t\", \"\\\\n\", \"\\u00b5\")\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"\\\\t\" \"\\\\n\" \"µ\"  \n```\n:::\n\n```{.r .cell-code}\nwriteLines(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\\t\n\\n\nµ\n```\n:::\n:::\n\n\n::: callout-tip\n### Example\n\nLet's take a look at a few examples of built in character sets: `\"\\w\"`, `\"\\d\"`, `\"\\s\"`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrepl(\"\\\\w\", \"abcdefghijklmnopqrstuvwxyz0123456789\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\ngrepl(\"\\\\d\", \"0123456789\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\n# \"\\n\" is the metacharacter for a new line\n# \"\\t\" is the metacharacter for a tab\ngrepl(\"\\\\s\", \"\\n\\t   \")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\ngrepl(\"\\\\d\", \"abcdefghijklmnopqrstuvwxyz\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\ngrepl(\"\\\\D\", \"abcdefghijklmnopqrstuvwxyz\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\ngrepl(\"\\\\w\", \"\\n\\t   \")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n:::\n\n## brackets\n\nYou can also **specify specific character sets** using **straight brackets** `[]`.\n\nFor example a **character set of just the vowels** would look like: `\"[aeiou]\"`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrepl(\"[aeiou]\", \"rhythms\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n\nYou can find the complement to a specific character by putting a carrot `^` after the first bracket. For example `\"[^aeiou]\"` matches all characters except the lowercase vowels.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrepl(\"[^aeiou]\", \"rhythms\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n## ranges\n\nYou can also **specify ranges of characters** using a **hyphen** `-` inside of the brackets.\n\nFor example:\n\n-   `\"[a-m]\"` matches all of the lowercase characters between `a` and `m`\n-   `\"[5-8]\"` matches any digit between 5 and 8 inclusive\n\n::: callout-tip\n### Example\n\nLet's take a look at some examples using custom character sets:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrepl(\"[a-m]\", \"xyz\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\ngrepl(\"[a-m]\", \"ABC\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\ngrepl(\"[a-mA-M]\", \"ABC\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n:::\n\n## beginning and end\n\nThere are also metacharacters for **matching the beginning** and **the end of a string** which are `\"^\"` and `\"$\"` respectively.\n\nLet's take a look at a few examples:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrepl(\"^a\", c(\"bab\", \"aab\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE  TRUE\n```\n:::\n\n```{.r .cell-code}\ngrepl(\"b$\", c(\"bab\", \"aab\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE TRUE\n```\n:::\n\n```{.r .cell-code}\ngrepl(\"^[ab]*$\", c(\"bab\", \"aab\", \"abc\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE  TRUE FALSE\n```\n:::\n:::\n\n\n## OR metacharacter\n\nThe last metacharacter we will discuss is the **OR metacharacter** (`\"|\"`).\n\nThe OR metacharacter **matches either the regex on the left or the regex on the right** side of this character. A few examples:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrepl(\"a|b\", c(\"abc\", \"bcd\", \"cde\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE  TRUE FALSE\n```\n:::\n\n```{.r .cell-code}\ngrepl(\"North|South\", c(\"South Dakota\", \"North Carolina\", \"West Virginia\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE  TRUE FALSE\n```\n:::\n:::\n\n\n## `state.name` example\n\n::: callout-tip\n### Example\n\nFinally, we have learned enough to create a regular expression that matches all state names that both begin and end with a vowel:\n\n1.  We match the beginning of a string.\n2.  We create a character set of just capitalized vowels.\n3.  We specify one instance of that set.\n4.  Then any number of characters until:\n5.  A character set of just lowercase vowels.\n6.  We specify one instance of that set.\n7.  We match the end of a string.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstart_end_vowel <- \"^[AEIOU]{1}.+[aeiou]{1}$\"\nvowel_state_lgl <- grepl(start_end_vowel, state.name)\nhead(vowel_state_lgl)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE  TRUE  TRUE FALSE FALSE FALSE\n```\n:::\n\n```{.r .cell-code}\nstate.name[vowel_state_lgl]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Alabama\"  \"Alaska\"   \"Arizona\"  \"Idaho\"    \"Indiana\"  \"Iowa\"     \"Ohio\"    \n[8] \"Oklahoma\"\n```\n:::\n:::\n\n:::\n\nBelow is a table of several important metacharacters:\n\n\n::: {.cell}\n::: {.cell-output-display}\n| Metacharacter |               Meaning                |\n|:-------------:|:------------------------------------:|\n|       .       |            Any Character             |\n|      \\\\w      |                A Word                |\n|      \\\\W      |              Not a Word              |\n|      \\\\d      |               A Digit                |\n|      \\\\D      |             Not a Digit              |\n|      \\\\s      |              Whitespace              |\n|      \\\\S      |            Not Whitespace            |\n|     [xyz]     |         A Set of Characters          |\n|    [^xyz]     |           Negation of Set            |\n|     [a-z]     |        A Range of Characters         |\n|       ^       |         Beginning of String          |\n|       $       |            End of String             |\n|      \\\\n      |               Newline                |\n|       +       |       One or More of Previous        |\n|       *       |       Zero or More of Previous       |\n|       ?       |       Zero or One of Previous        |\n|    &#124;     | Either the Previous or the Following |\n|      {5}      |        Exactly 5 of Previous         |\n|    {2, 5}     |     Between 2 and 5 or Previous      |\n|     {2, }     |       More than 2 of Previous        |\n:::\n:::\n\n\n# Other regex in base R\n\nSo far we've been using `grepl()` to see if a regex matches a string. There are a few other built in regex functions you should be aware of.\n\nFirst, we will review our workhorse of this lesson, `grepl()`, which stands for \"grep logical.\"\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrepl(\"[Ii]\", c(\"Hawaii\", \"Illinois\", \"Kentucky\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE  TRUE FALSE\n```\n:::\n:::\n\n\n## `grep()`\n\nThen, there is old fashioned `grep(pattern, x)`, which **returns the indices of the vector** that match the regex:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrep(pattern = \"[Ii]\", x = c(\"Hawaii\", \"Illinois\", \"Kentucky\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2\n```\n:::\n:::\n\n\n## `sub()`\n\nThe `sub(pattern, replacement, x)` function takes as arguments a regex, a \"replacement,\" and a vector of strings. This function will **replace the first instance of that regex found in each string**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsub(pattern = \"[Ii]\", replacement = \"1\", x = c(\"Hawaii\", \"Illinois\", \"Kentucky\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Hawa1i\"   \"1llinois\" \"Kentucky\"\n```\n:::\n:::\n\n\n## `gsub()`\n\nThe `gsub(pattern, replacement, x)` function is nearly the same as `sub()` except it will **replace every instance of the regex** that is matched in each string.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngsub(\"[Ii]\", \"1\", c(\"Hawaii\", \"Illinois\", \"Kentucky\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Hawa11\"   \"1ll1no1s\" \"Kentucky\"\n```\n:::\n:::\n\n\n## `strsplit()`\n\nThe `strsplit(x, split)` function will **split up strings** (`split`) according to the provided regex (`x`) .\n\nIf `strsplit()` is provided with a vector of strings it will return a list of string vectors.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntwo_s <- state.name[grep(\"ss\", state.name)]\ntwo_s\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Massachusetts\" \"Mississippi\"   \"Missouri\"      \"Tennessee\"    \n```\n:::\n\n```{.r .cell-code}\nstrsplit(x = two_s, split = \"ss\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] \"Ma\"        \"achusetts\"\n\n[[2]]\n[1] \"Mi\"   \"i\"    \"ippi\"\n\n[[3]]\n[1] \"Mi\"   \"ouri\"\n\n[[4]]\n[1] \"Tenne\" \"ee\"   \n```\n:::\n:::\n\n\n# The stringr package\n\nThe [`stringr`](https://github.com/hadley/stringr) package, written by [Hadley Wickham](http://hadley.nz/), is part of the [Tidyverse](https://twitter.com/hadleywickham/status/751805589425000450) group of R packages.\n\nThis package **takes a \"data first\" approach to functions involving regex**, so usually the string is the first argument and the regex is the second argument.\n\nThe majority of the function names in `stringr` **begin** with `str_*()`.\n\n![](https://raw.githubusercontent.com/rstudio/cheatsheets/master/pngs/thumbnails/strings-cheatsheet-thumbs.png){preview=\"TRUE\"}\n\n\\[**Source**: <https://stringr.tidyverse.org> \\]\n\n## `str_extract`\n\nThe `str_extract(string, pattern)` function returns the sub-string of a string (`string`) that matches the provided regular expression (`pattern`).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(stringr)\nstate_tbl <- paste(state.name, state.area, state.abb)\nhead(state_tbl)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Alabama 51609 AL\"     \"Alaska 589757 AK\"     \"Arizona 113909 AZ\"   \n[4] \"Arkansas 53104 AR\"    \"California 158693 CA\" \"Colorado 104247 CO\"  \n```\n:::\n\n```{.r .cell-code}\nstr_extract(state_tbl, \"[0-9]+\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"51609\"  \"589757\" \"113909\" \"53104\"  \"158693\" \"104247\" \"5009\"   \"2057\"  \n [9] \"58560\"  \"58876\"  \"6450\"   \"83557\"  \"56400\"  \"36291\"  \"56290\"  \"82264\" \n[17] \"40395\"  \"48523\"  \"33215\"  \"10577\"  \"8257\"   \"58216\"  \"84068\"  \"47716\" \n[25] \"69686\"  \"147138\" \"77227\"  \"110540\" \"9304\"   \"7836\"   \"121666\" \"49576\" \n[33] \"52586\"  \"70665\"  \"41222\"  \"69919\"  \"96981\"  \"45333\"  \"1214\"   \"31055\" \n[41] \"77047\"  \"42244\"  \"267339\" \"84916\"  \"9609\"   \"40815\"  \"68192\"  \"24181\" \n[49] \"56154\"  \"97914\" \n```\n:::\n:::\n\n\n## `str_detect`\n\nThe `str_detect(string, pattern)` is equivalent to `grepl(pattern,x)`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_detect(state_tbl, \"[0-9]+\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[16] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[31] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[46] TRUE TRUE TRUE TRUE TRUE\n```\n:::\n\n```{.r .cell-code}\ngrepl(\"[0-9]+\", state_tbl)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[16] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[31] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[46] TRUE TRUE TRUE TRUE TRUE\n```\n:::\n:::\n\n\nIt detects the presence or absence of a pattern in a string.\n\n## `str_order`\n\nThe `str_order(x)` function returns a numeric vector that corresponds to the alphabetical order of the strings in the provided vector (`x`).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(state.name)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Alabama\"    \"Alaska\"     \"Arizona\"    \"Arkansas\"   \"California\"\n[6] \"Colorado\"  \n```\n:::\n\n```{.r .cell-code}\nstr_order(state.name)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50\n```\n:::\n\n```{.r .cell-code}\nhead(state.abb)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"AL\" \"AK\" \"AZ\" \"AR\" \"CA\" \"CO\"\n```\n:::\n\n```{.r .cell-code}\nstr_order(state.abb)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  2  1  4  3  5  6  7  8  9 10 11 15 12 13 14 16 17 18 21 20 19 22 23 25 24\n[26] 26 33 34 27 29 30 31 28 32 35 36 37 38 39 40 41 42 43 44 46 45 47 49 48 50\n```\n:::\n:::\n\n\n## `str_replace`\n\nThe `str_replace(string, pattern, replace)` is equivalent to `sub(pattern, replacement, x)`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_replace(string = state.name, pattern = \"[Aa]\", replace = \"B\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"Blabama\"        \"Blaska\"         \"Brizona\"        \"Brkansas\"      \n [5] \"CBlifornia\"     \"ColorBdo\"       \"Connecticut\"    \"DelBware\"      \n [9] \"FloridB\"        \"GeorgiB\"        \"HBwaii\"         \"IdBho\"         \n[13] \"Illinois\"       \"IndiBna\"        \"IowB\"           \"KBnsas\"        \n[17] \"Kentucky\"       \"LouisiBna\"      \"MBine\"          \"MBryland\"      \n[21] \"MBssachusetts\"  \"MichigBn\"       \"MinnesotB\"      \"Mississippi\"   \n[25] \"Missouri\"       \"MontBna\"        \"NebrBska\"       \"NevBda\"        \n[29] \"New HBmpshire\"  \"New Jersey\"     \"New Mexico\"     \"New York\"      \n[33] \"North CBrolina\" \"North DBkota\"   \"Ohio\"           \"OklBhoma\"      \n[37] \"Oregon\"         \"PennsylvBnia\"   \"Rhode IslBnd\"   \"South CBrolina\"\n[41] \"South DBkota\"   \"Tennessee\"      \"TexBs\"          \"UtBh\"          \n[45] \"Vermont\"        \"VirginiB\"       \"WBshington\"     \"West VirginiB\" \n[49] \"Wisconsin\"      \"Wyoming\"       \n```\n:::\n\n```{.r .cell-code}\nsub(pattern = \"[Aa]\", replacement = \"B\", x = state.name)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"Blabama\"        \"Blaska\"         \"Brizona\"        \"Brkansas\"      \n [5] \"CBlifornia\"     \"ColorBdo\"       \"Connecticut\"    \"DelBware\"      \n [9] \"FloridB\"        \"GeorgiB\"        \"HBwaii\"         \"IdBho\"         \n[13] \"Illinois\"       \"IndiBna\"        \"IowB\"           \"KBnsas\"        \n[17] \"Kentucky\"       \"LouisiBna\"      \"MBine\"          \"MBryland\"      \n[21] \"MBssachusetts\"  \"MichigBn\"       \"MinnesotB\"      \"Mississippi\"   \n[25] \"Missouri\"       \"MontBna\"        \"NebrBska\"       \"NevBda\"        \n[29] \"New HBmpshire\"  \"New Jersey\"     \"New Mexico\"     \"New York\"      \n[33] \"North CBrolina\" \"North DBkota\"   \"Ohio\"           \"OklBhoma\"      \n[37] \"Oregon\"         \"PennsylvBnia\"   \"Rhode IslBnd\"   \"South CBrolina\"\n[41] \"South DBkota\"   \"Tennessee\"      \"TexBs\"          \"UtBh\"          \n[45] \"Vermont\"        \"VirginiB\"       \"WBshington\"     \"West VirginiB\" \n[49] \"Wisconsin\"      \"Wyoming\"       \n```\n:::\n:::\n\n\n## `str_pad`\n\nThe `str_pad(string, width, side, pad)` function pads strings (`string`) with other characters, which is often useful when the string is going to be eventually printed for a person to read.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_pad(\"Thai\", width = 8, side = \"left\", pad = \"-\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"----Thai\"\n```\n:::\n\n```{.r .cell-code}\nstr_pad(\"Thai\", width = 8, side = \"right\", pad = \"-\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Thai----\"\n```\n:::\n\n```{.r .cell-code}\nstr_pad(\"Thai\", width = 8, side = \"both\", pad = \"-\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"--Thai--\"\n```\n:::\n:::\n\n\nThe `str_to_title(string)` function acts just like `tolower()` and `toupper()` except it puts strings into Title Case.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncases <- c(\"CAPS\", \"low\", \"Title\")\nstr_to_title(cases)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Caps\"  \"Low\"   \"Title\"\n```\n:::\n:::\n\n\n## `str_trim`\n\nThe `str_trim(string)` function deletes white space from both sides of a string.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nto_trim <- c(\"   space\", \"the    \", \"    final frontier  \")\nstr_trim(to_trim)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"space\"          \"the\"            \"final frontier\"\n```\n:::\n:::\n\n\n## `str_wrap`\n\nThe `str_wrap(string)` function inserts newlines in strings so that when the string is printed each line's length is limited.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npasted_states <- paste(state.name[1:20], collapse = \" \")\n\ncat(str_wrap(pasted_states, width = 80))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAlabama Alaska Arizona Arkansas California Colorado Connecticut Delaware Florida\nGeorgia Hawaii Idaho Illinois Indiana Iowa Kansas Kentucky Louisiana Maine\nMaryland\n```\n:::\n\n```{.r .cell-code}\ncat(str_wrap(pasted_states, width = 30))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAlabama Alaska Arizona\nArkansas California Colorado\nConnecticut Delaware Florida\nGeorgia Hawaii Idaho Illinois\nIndiana Iowa Kansas Kentucky\nLouisiana Maine Maryland\n```\n:::\n:::\n\n\n## `word`\n\nThe `word()` function allows you to index each word in a string as if it were a vector.\n\n\n::: {.cell}\n\n```{.r .cell-code}\na_tale <- \"It was the best of times it was the worst of times it was the age of wisdom it was the age of foolishness\"\n\nword(a_tale, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"was\"\n```\n:::\n\n```{.r .cell-code}\nword(a_tale, end = 3) # end = last word to extract\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"It was the\"\n```\n:::\n\n```{.r .cell-code}\nword(a_tale, start = 11, end = 15) # start = first word to extract\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"of times it was the\"\n```\n:::\n:::\n\n\n# Post-lecture materials\n\n### Final Questions\n\nHere are some post-lecture questions to help you think about the material discussed.\n\n::: callout-note\n### Questions\n\nThere is a corpus of common words here:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(stringr::words)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"a\"        \"able\"     \"about\"    \"absolute\" \"accept\"   \"account\" \n```\n:::\n\n```{.r .cell-code}\nlength(stringr::words)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 980\n```\n:::\n:::\n\n\n1.  Using `stringr::words`, create regular expressions that find all words that:\n\n-   Start with \"y\".\n-   End with \"x\"\n-   Are exactly three letters long. (Don't cheat by using str_length()!)\n-   Have seven letters or more.\n\n2.  Using the same `stringr::words`, create regular expressions to find all words that:\n\n-   Start with a vowel.\n-   That only contain consonants. (Hint: thinking about matching \"not\"-vowels.)\n-   End with `ed`, but not with `eed`.\n-   End with `ing` or `ise`.\n:::\n\n### Additional Resources\n\n::: callout-tip\n-   <https://stringr.tidyverse.org>\n-   <https://rdpeng.github.io/Biostat776/lecture-regular-expressions>\n-   <https://r4ds.had.co.nz/strings>\n:::\n\n# R session information\n\n\n::: {.cell}\n\n```{.r .cell-code}\noptions(width = 120)\nsessioninfo::session_info()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n─ Session info ───────────────────────────────────────────────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.3.1 (2023-06-16)\n os       macOS Ventura 13.5\n system   aarch64, darwin20\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       America/New_York\n date     2023-08-17\n pandoc   3.1.5 @ /opt/homebrew/bin/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────────────────────────────────────────────────\n package     * version date (UTC) lib source\n cli           3.6.1   2023-03-23 [1] CRAN (R 4.3.0)\n colorout      1.2-2   2023-05-06 [1] Github (jalvesaq/colorout@79931fd)\n digest        0.6.33  2023-07-07 [1] CRAN (R 4.3.0)\n evaluate      0.21    2023-05-05 [1] CRAN (R 4.3.0)\n fastmap       1.1.1   2023-02-24 [1] CRAN (R 4.3.0)\n glue          1.6.2   2022-02-24 [1] CRAN (R 4.3.0)\n htmltools     0.5.6   2023-08-10 [1] CRAN (R 4.3.0)\n htmlwidgets   1.6.2   2023-03-17 [1] CRAN (R 4.3.0)\n jsonlite      1.8.7   2023-06-29 [1] CRAN (R 4.3.0)\n knitr       * 1.43    2023-05-25 [1] CRAN (R 4.3.0)\n lifecycle     1.0.3   2022-10-07 [1] CRAN (R 4.3.0)\n magrittr      2.0.3   2022-03-30 [1] CRAN (R 4.3.0)\n rlang         1.1.1   2023-04-28 [1] CRAN (R 4.3.0)\n rmarkdown     2.24    2023-08-14 [1] CRAN (R 4.3.1)\n rstudioapi    0.15.0  2023-07-07 [1] CRAN (R 4.3.0)\n sessioninfo   1.2.2   2021-12-06 [1] CRAN (R 4.3.0)\n stringi       1.7.12  2023-01-11 [1] CRAN (R 4.3.0)\n stringr     * 1.5.0   2022-12-02 [1] CRAN (R 4.3.0)\n vctrs         0.6.3   2023-06-14 [1] CRAN (R 4.3.0)\n xfun          0.40    2023-08-09 [1] CRAN (R 4.3.0)\n yaml          2.3.7   2023-01-23 [1] CRAN (R 4.3.0)\n\n [1] /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/library\n\n──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}