{
  "hash": "45161be513d3df2dbb7d394c622bfa30",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"17 - Vectorization and loop functionals\"\nauthor:\n  - name: Leonardo Collado Torres\n    url: http://lcolladotor.github.io/\n    affiliations:\n      - id: libd\n        name: Lieber Institute for Brain Development\n        url: https://libd.org/\n      - id: jhsph\n        name: Johns Hopkins Bloomberg School of Public Health Department of Biostatistics\n        url: https://publichealth.jhu.edu/departments/biostatistics\ndescription: \"Introduction to vectorization and loop functionals\"\ncategories: [module 4, week 5, R, programming, functions]\n---\n\n\n*This lecture, as the rest of the course, is adapted from the version [Stephanie C. Hicks](https://www.stephaniehicks.com/) designed and maintained in 2021 and 2022. Check the recent changes to this file through the [GitHub history](https://github.com/lcolladotor/jhustatcomputing/commits/main/posts/17-loop-functions/index.qmd).*\n\n<!-- Add interesting quote -->\n\n# Pre-lecture materials\n\n### Read ahead\n\n::: callout-note\n## Read ahead\n\n**Before class, you can prepare by reading the following materials:**\n\n1.  <https://rafalab.github.io/dsbook/programming-basics.html#vectorization>\n:::\n\n### Acknowledgements\n\nMaterial for this lecture was borrowed and adopted from\n\n-   <https://rdpeng.github.io/Biostat776/lecture-loop-functions>\n-   <https://rafalab.github.io/dsbook/programming-basics.html#vectorization>\n\n# Learning objectives\n\n::: callout-note\n# Learning objectives\n\n**At the end of this lesson you will:**\n\n-   Understand how to perform vector arithmetics in R\n-   Implement the 5 functional loops in R (vs e.g. for loops) in R\n:::\n\n# Vectorization\n\nWriting `for` and `while` loops are useful and easy to understand, but in R we rarely use them.\n\nAs you learn more R, you will realize that **vectorization** is preferred over for-loops since it results in shorter and clearer code.\n\n## Vector arithmetics\n\n### Rescaling a vector\n\nIn R, arithmetic operations on **vectors occur element-wise**. For a quick example, suppose we have height in inches:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninches <- c(69, 62, 66, 70, 70, 73, 67, 73, 67, 70)\n```\n:::\n\n\nand want to convert to centimeters.\n\nNotice what happens when we multiply inches by 2.54:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninches * 2.54\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 175.26 157.48 167.64 177.80 177.80 185.42 170.18 185.42 170.18 177.80\n```\n\n\n:::\n:::\n\n\nIn the line above, we **multiplied each element** by 2.54.\n\nSimilarly, if for each entry we want to compute how many inches taller or shorter than 69 inches (the average height for males), we can subtract it from every entry like this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninches - 69\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  0 -7 -3  1  1  4 -2  4 -2  1\n```\n\n\n:::\n:::\n\n\n### Two vectors\n\nIf we have **two vectors of the same length**, and we sum them in R, they will be **added entry by entry** as follows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:10\ny <- 1:10\nx + y\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  2  4  6  8 10 12 14 16 18 20\n```\n\n\n:::\n:::\n\n\nThe same holds for other mathematical operations, such as `-`, `*` and `/`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:10\nsqrt(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 1.000000 1.414214 1.732051 2.000000 2.236068 2.449490 2.645751 2.828427\n [9] 3.000000 3.162278\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- 1:10\nx * y\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]   1   4   9  16  25  36  49  64  81 100\n```\n\n\n:::\n:::\n\n\nThat is, we don't write a `for` loop that takes each element of `x` and each element of `y`, adds, them up, then puts them all in a single vector.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Check that x and y have the same length\nstopifnot(length(x) == length(y))\n\n## Create our result object\nresult <- vector(mode = \"integer\", length = length(x))\n\n## Loop through each element of x and y, calculate the sum,\n## then store it on 'result'\nfor (i in seq_along(x)) {\n    result[i] <- x[i] + y[i]\n}\n\n## Check that we got the same answer\nidentical(result, x + y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n# Functional loops\n\nWhile `for` loops are perfectly valid, when you use vectorization in an element-wise fashion, there is no need for `for` loops because we can apply what are called functional loops.\n\n**Functional loops** are functions that help us apply the same function to each entry in a vector, matrix, data frame, or list. Here are a list of them in base R:\n\n-   `lapply()`: Loop over a list and evaluate a function on each element\n\n-   `sapply()`: Same as `lapply` but try to simplify the result\n\n-   `apply()`: Apply a function over the margins of an array\n\n-   `tapply()`: Apply a function over subsets of a vector\n\n-   `mapply()`: Multivariate version of `lapply` (won't cover)\n\nAn auxiliary function `split()` is also useful, particularly in conjunction with `lapply()`.\n\n## Define a function\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_sum <- function(a, b) {\n    a + b\n}\n\n## Same but with an extra check to make sure that 'a' and 'b'\n## have the same lengths.\nmy_sum <- function(a, b) {\n    ## Check that a and b are of the same length\n    stopifnot(length(a) == length(b))\n    a + b\n}\n```\n:::\n\n\n## Extra material: document + test + share functions\n\n### Document your function with `roxygen2`\n\nExtra: document your function with `roxygen2` syntax. `Code` (or magic wand) -\\> `Insert Roxygen skeleton` . For more details about `roxygen2` check <https://r-pkgs.org/man.html> and <https://cran.r-project.org/web/packages/roxygen2/vignettes/roxygen2.html>.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#' Title\n#'\n#' @param a\n#' @param b\n#'\n#' @return\n#' @export\n#'\n#' @examples\nmy_sum <- function(a, b) {\n    ## Check that a and b are of the same length\n    stopifnot(length(a) == length(b))\n    a + b\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#' Title\n#'\n#' Description\n#'\n#' Details\n#'\n#' @param a What is `a`?\n#' @param b What is `b`?\n#'\n#' @return What does the function return?\n#' @export ## Do we want to share this function? yes!\n#'\n#' @examples\n#' ## How do you use this function?\nmy_sum <- function(a, b) {\n    ## Check that a and b are of the same length\n    stopifnot(length(a) == length(b))\n    a + b\n}\n```\n:::\n\n\nHere is a full example\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#' Sum two vectors\n#'\n#' This function does the element wise sum of two vectors.\n#'\n#' It really is just an example function that is powered by the `+` operator\n#' from [base::Arithmetic].\n#'\n#' @param a An `integer()` or `numeric()` vector of length `L`.\n#' @param b An `integer()` or `numeric()` vector of length `L`.\n#'\n#' @return An `integer()` or `numeric()` vector of length `L` with\n#' the element-wise sum of `a` and `b`.\n#' @export\n#'\n#' @examples\n#' ## Generate some input data\n#' x <- 1:10\n#' y <- 1:10\n#'\n#' ## Perform the element wise sum\n#' my_sum(x, y)\nmy_sum <- function(a, b) {\n    ## Check that a and b are of the same length\n    stopifnot(length(a) == length(b))\n    a + b\n}\n```\n:::\n\n\n### Test your function with `testthat`\n\nBelow will use two `expect_*()` functions from `testthat`. For more details, check <https://r-pkgs.org/testing-basics.html>.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"testthat\")\ntest_that(\"my_sum works\", {\n    x <- seq_len(10)\n    expect_equal(my_sum(x, x), x + x)\n\n    expect_error(my_sum(x, seq_len(5)))\n})\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nTest passed ðŸ¥³\n```\n\n\n:::\n:::\n\n\n### Share your function in an R package\n\nWhat even more? Make an R package to share this function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Install biocthis if you don't have it\nif (!require(\"BiocManager\", quietly = TRUE)) {\n    install.packages(\"BiocManager\")\n}\n\nBiocManager::install(\"biocthis\")\n\n## Create an empty R package that is also an\n## RStudio project\nusethis::create_package(\"~/Desktop/sum776\")\n\n## On the new RStudio window, create the\n## scripts that will guide you into making a package\nbiocthis::use_bioc_pkg_templates()\n```\n:::\n\n\nSee my example at <https://github.com/lcolladotor/sum776> with its documentation website <https://lcolladotor.github.io/sum776/>. The documentation we wrote for our function is shown at <https://lcolladotor.github.io/sum776/reference/my_sum.html>.\n\nAs this package is fully functional and tested (see <https://github.com/lcolladotor/sum776/actions> and in particular <https://github.com/lcolladotor/sum776/actions/runs/6305876152/job/17120052804#step:20:27>), we can install it from GitHub as any other R package on GitHub.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nremotes::install_github(\"lcolladotor/sum776\")\n```\n:::\n\n\n### Build your own R package with your custom-made `ggplot2` theme\n\nAs you can see from <https://github.com/MatthewBJane/ThemePark/blob/main/R/theme_barbie.R>, it doesn't take a lot of R code to write a custom theme. See the following video for more on custom `ggplot2` themes.\n\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/7GqXssfzQYE?si=cxBbtCCjIs1t21qS\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen>\n\n</iframe>\n\n## Apply your function\n\nHere since we have two input vectors, we need to use `mapply()` which is one of the more complex functions. Note the weird order of the arguments where the function we will `mapply()` over comes before the inputs to said function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Check the arguments to mapply()\nargs(mapply)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfunction (FUN, ..., MoreArgs = NULL, SIMPLIFY = TRUE, USE.NAMES = TRUE) \nNULL\n```\n\n\n:::\n\n```{.r .cell-code}\n## Apply mapply() to our function my_sum() with the inputs 'x' and 'y'\nmapply(sum776::my_sum, x, y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  2  4  6  8 10 12 14 16 18 20\n```\n\n\n:::\n\n```{.r .cell-code}\n## Or write an anynymous function that is:\n## * not documented\n## * not tested\n## * not shared\n##\n## :(\nmapply(function(a, b) {\n    a + b\n}, x, y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  2  4  6  8 10 12 14 16 18 20\n```\n\n\n:::\n:::\n\n\n# `purrr` alternative\n\nThe [`purrr`](https://purrr.tidyverse.org/) package, which is part of the `tidyverse`, provides an alternative framework to the `apply` family of functions in base R.\n\n[![Three green fuzzy monsters in chef hats frosting cupcakes with the same vanilla frosting. A purple fuzzy monster to the side holds a recipe book containing code that would automate the cupcake frosting process. By Allison Horst.](https://cdn.myportfolio.com/45214904-6a61-4e23-98d6-b140f8654a40/66ad455b-a0fc-4c61-8a5c-fb091f8b7f36_rw_3840.png?h=b4d401a70fe73cc06ad53aeae285981f)](https://allisonhorst.com/wickham-tidy-bakers)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"purrr\") ## part of tidyverse\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n## Check the arguments of map2_int()\nargs(purrr::map2_int)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfunction (.x, .y, .f, ..., .progress = FALSE) \nNULL\n```\n\n\n:::\n\n```{.r .cell-code}\n## Apply our function my_sum() to our inputs\npurrr::map2_int(x, y, sum776::my_sum)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  2  4  6  8 10 12 14 16 18 20\n```\n\n\n:::\n\n```{.r .cell-code}\n## You can also use anonymous functions\npurrr::map2_int(x, y, function(a, b) {\n    a + b\n})\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  2  4  6  8 10 12 14 16 18 20\n```\n\n\n:::\n\n```{.r .cell-code}\n## purrr even has a super short formula-like syntax\n## where .x is the first input and .y is the second one\npurrr::map2_int(x, y, ~ .x + .y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  2  4  6  8 10 12 14 16 18 20\n```\n\n\n:::\n\n```{.r .cell-code}\n## This formula syntax has nothing to do with the objects 'x' and 'y'\npurrr::map2_int(1:2, 3:4, ~ .x + .y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4 6\n```\n\n\n:::\n:::\n\n\n[![Three green fuzzy monsters in chef hats frosting cupcakes with three different frostings. A purple fuzzy monster to the side holds a recipe book containing code that would automate the cupcake frosting process. By Allison Horst.](https://cdn.myportfolio.com/45214904-6a61-4e23-98d6-b140f8654a40/07bae254-62c4-4fd9-a165-acdeff1667de_rw_3840.png?h=f3abf97961c21249eb4de47a98540b4c){fig-align=\"center\"}](https://allisonhorst.com/wickham-tidy-bakers)\n\n# Base R loops\n\n## `lapply()`\n\nThe `lapply()` function does the following simple series of operations:\n\n1.  it loops over a list, iterating over each element in that list\n2.  it applies a *function* to each element of the list (a function that you specify)\n3.  and returns a list (the `l` in `lapply()` is for \"list\").\n\nThis function takes three arguments: (1) a list `X`; (2) a function (or the name of a function) `FUN`; (3) other arguments via its `...` argument. If `X` is not a list, it will be coerced to a list using `as.list()`.\n\nThe body of the `lapply()` function can be seen here.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlapply\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfunction (X, FUN, ...) \n{\n    FUN <- match.fun(FUN)\n    if (!is.vector(X) || is.object(X)) \n        X <- as.list(X)\n    .Internal(lapply(X, FUN))\n}\n<bytecode: 0x11f13b800>\n<environment: namespace:base>\n```\n\n\n:::\n:::\n\n\n::: callout-tip\n### Note\n\nThe actual looping is done internally in C code for efficiency reasons.\n:::\n\nIt is important to remember that `lapply()` always returns a list, regardless of the class of the input.\n\n::: callout-tip\n### Example\n\nHere's an example of applying the `mean()` function to all elements of a list. If the original list has names, the the names will be preserved in the output.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- list(a = 1:5, b = rnorm(10))\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$a\n[1] 1 2 3 4 5\n\n$b\n [1]  1.74674240  0.61327895  0.07430473  0.42115141 -0.64381753  1.42263258\n [7]  0.28278509 -0.15372358  0.22298620  0.23411131\n```\n\n\n:::\n\n```{.r .cell-code}\nlapply(x, mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$a\n[1] 3\n\n$b\n[1] 0.4220452\n```\n\n\n:::\n:::\n\n\nNotice that here we are passing the `mean()` function as an argument to the `lapply()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npurrr::map_dbl(x, mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n        a         b \n3.0000000 0.4220452 \n```\n\n\n:::\n:::\n\n\nWhat difference do you notice in terms of the output of `lapply()` and `purrr::map_dbl()`?\n\n\n::: {.cell}\n\n```{.r .cell-code}\npurrr::map(x, mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$a\n[1] 3\n\n$b\n[1] 0.4220452\n```\n\n\n:::\n:::\n\n:::\n\n**Functions in R can be** used this way and can be **passed back and forth as arguments** just like any other object in R.\n\nWhen you pass a function to another function, you do not need to include the open and closed parentheses `()` like you do when you are **calling** a function.\n\n::: callout-tip\n### Example\n\nHere is another example of using `lapply()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- list(a = 1:4, b = rnorm(10), c = rnorm(20, 1), d = rnorm(100, 5))\nlapply(x, mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$a\n[1] 2.5\n\n$b\n[1] 0.1018754\n\n$c\n[1] 1.175001\n\n$d\n[1] 5.067207\n```\n\n\n:::\n:::\n\n:::\n\nYou can use `lapply()` to evaluate a function multiple times each with a different argument.\n\nNext is an example where I call the `runif()` function (to generate uniformly distributed random variables) four times, each time generating a different number of random numbers.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:4\nlapply(x, runif)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 0.9155942\n\n[[2]]\n[1] 0.602441604 0.005958148\n\n[[3]]\n[1] 0.3745703 0.4737332 0.1189540\n\n[[4]]\n[1] 0.53275194 0.02855169 0.47440699 0.61104526\n```\n\n\n:::\n:::\n\n\n::: callout-tip\n### What happened?\n\nWhen you pass a function to `lapply()`, `lapply()` takes elements of the list and passes them as the *first argument* of the function you are applying.\n\nIn the above example, the first argument of `runif()` is `n`, and so the elements of the sequence `1:4` all got passed to the `n` argument of `runif()`.\n\nThis also works with `purrr` functions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npurrr::map(x, runif)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 0.8648622\n\n[[2]]\n[1] 0.4445934 0.4638005\n\n[[3]]\n[1] 0.1732884 0.3674504 0.6362085\n\n[[4]]\n[1] 0.4247436 0.4139468 0.8514355 0.7666486\n```\n\n\n:::\n:::\n\n:::\n\nFunctions that you pass to `lapply()` may have other arguments. For example, the `runif()` function has a `min` and `max` argument too.\n\n::: callout-note\n### Question\n\nIn the example above I used the default values for `min` and `max`.\n\n-   How would you be able to specify different values for that in the context of `lapply()`?\n:::\n\nHere is where the `...` argument to `lapply()` comes into play. Any arguments that you place in the `...` argument will get passed down to the function being applied to the elements of the list.\n\nHere, the `min = 0` and `max = 10` arguments are passed down to `runif()` every time it gets called.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:4\nlapply(x, runif, min = 0, max = 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 5.62294\n\n[[2]]\n[1] 6.120768 6.683343\n\n[[3]]\n[1] 6.387056 4.371937 4.937801\n\n[[4]]\n[1] 9.680522 4.438564 3.734991 6.373060\n```\n\n\n:::\n:::\n\n\nSo now, instead of the random numbers being between 0 and 1 (the default), the are all between 0 and 10. Again, this also works with `purrr` functions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npurrr::map(x, runif, min = 0, max = 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 1.801176\n\n[[2]]\n[1] 7.973248 6.898636\n\n[[3]]\n[1] 5.3614468 1.4021785 0.3117477\n\n[[4]]\n[1] 7.1906605 4.8297006 0.3616360 0.3355722\n```\n\n\n:::\n:::\n\n\nThe `lapply()` function (and its friends) makes heavy use of *anonymous* functions. Anonymous functions are like members of [Project Mayhem](http://en.wikipedia.org/wiki/Fight_Club)---they have no names. These functions are generated \"on the fly\" as you are using `lapply()`. Once the call to `lapply()` is finished, the function disappears and does not appear in the workspace.\n\n::: callout-tip\n### Example\n\nHere I am creating a list that contains two matrices.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- list(a = matrix(1:4, 2, 2), b = matrix(1:6, 3, 2))\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$a\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\n$b\n     [,1] [,2]\n[1,]    1    4\n[2,]    2    5\n[3,]    3    6\n```\n\n\n:::\n:::\n\n\nSuppose I wanted to extract the first column of each matrix in the list. I could write an anonymous function for extracting the first column of each matrix.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlapply(x, function(elt) {\n    elt[, 1]\n})\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$a\n[1] 1 2\n\n$b\n[1] 1 2 3\n```\n\n\n:::\n:::\n\n\nNotice that I put the `function()` definition right in the call to `lapply()`.\n:::\n\nThis is perfectly legal and acceptable. You can put an arbitrarily complicated function definition inside `lapply()`, but if it's going to be more complicated, it's probably a better idea to define the function separately.\n\nFor example, I could have done the following.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf <- function(elt) {\n    elt[, 1]\n}\nlapply(x, f)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$a\n[1] 1 2\n\n$b\n[1] 1 2 3\n```\n\n\n:::\n:::\n\n\n::: callout-tip\n### Note\n\nNow the function is no longer anonymous; its name is `f`.\n:::\n\nWhether you use an anonymous function or you define a function first depends on your context. If you think the function `f` is something you are going to need a lot in other parts of your code, you might want to define it separately. But if you are just going to use it for this call to `lapply()`, then it is probably simpler to use an anonymous function.\n\n## `sapply()`\n\nThe `sapply()` function behaves similarly to `lapply()`; the only real difference is in the return value. `sapply()` will try to simplify the result of `lapply()` if possible. Essentially, `sapply()` calls `lapply()` on its input and then applies the following algorithm:\n\n-   If the result is a list where every element is length 1, then a vector is returned\n\n-   If the result is a list where every element is a vector of the same length (\\> 1), a matrix is returned.\n\n-   If it can't figure things out, a list is returned\n\n    -   This can be a source of many headaches and one of the main motivations behind the `purrr` package. With `purrr` you know exactly what type of output you are getting!\n\nHere's the result of calling `lapply()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- list(a = 1:4, b = rnorm(10), c = rnorm(20, 1), d = rnorm(100, 5))\nlapply(x, mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$a\n[1] 2.5\n\n$b\n[1] -0.0289228\n\n$c\n[1] 0.8240488\n\n$d\n[1] 5.089893\n```\n\n\n:::\n:::\n\n\nNotice that `lapply()` returns a list (as usual), but that each element of the list has length 1.\n\nHere's the result of calling `sapply()` on the same list.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsapply(x, mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n         a          b          c          d \n 2.5000000 -0.0289228  0.8240488  5.0898927 \n```\n\n\n:::\n:::\n\n\nBecause the result of `lapply()` was a list where each element had length 1, `sapply()` collapsed the output into a numeric vector, which is often more useful than a list.\n\nWith `purrr`, if I want a list output, I use `map()`. If I want a double (numeric) output, we can use `map_dbl()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npurrr::map(x, mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$a\n[1] 2.5\n\n$b\n[1] -0.0289228\n\n$c\n[1] 0.8240488\n\n$d\n[1] 5.089893\n```\n\n\n:::\n\n```{.r .cell-code}\npurrr::map_dbl(x, mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n         a          b          c          d \n 2.5000000 -0.0289228  0.8240488  5.0898927 \n```\n\n\n:::\n:::\n\n\n## `split()`\n\nThe `split()` function takes a vector or other objects and splits it into groups determined by a factor or list of factors.\n\nThe arguments to `split()` are\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(split)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfunction (x, f, drop = FALSE, ...)  \n```\n\n\n:::\n:::\n\n\nwhere\n\n-   `x` is a vector (or list) or data frame\n-   `f` is a factor (or coerced to one) or a list of factors\n-   `drop` indicates whether empty factors levels should be dropped\n\nThe combination of `split()` and a function like `lapply()` or `sapply()` is a common paradigm in R. The basic idea is that you can take a data structure, split it into subsets defined by another variable, and apply a function over those subsets. The results of applying that function over the subsets are then collated and returned as an object. This sequence of operations is sometimes referred to as \"map-reduce\" in other contexts.\n\nHere we simulate some data and split it according to a factor variable. Note that we use the `gl()` function to \"generate levels\" in a factor variable.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(rnorm(10), runif(10), rnorm(10, 1))\nf <- gl(3, 10) # generate factor levels\nf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3\nLevels: 1 2 3\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsplit(x, f)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$`1`\n [1]  0.036889250  0.439156242 -0.171449018  0.268308762 -0.005784603\n [6] -0.037474725  0.571768648 -0.509378178 -2.206236031 -0.622883084\n\n$`2`\n [1] 0.4008668 0.2120854 0.9700646 0.7878063 0.6285846 0.1459494 0.9827753\n [8] 0.4098482 0.1778611 0.4292090\n\n$`3`\n [1] -0.73843715 -0.11862435  1.13214158  0.82010277  0.55687342 -0.07636030\n [7]  2.45904045  0.57225537  0.02053563  0.44537470\n```\n\n\n:::\n:::\n\n\nA common idiom is `split` followed by an `lapply`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlapply(split(x, f), mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$`1`\n[1] -0.2237083\n\n$`2`\n[1] 0.5145051\n\n$`3`\n[1] 0.5072902\n```\n\n\n:::\n:::\n\n\n### Splitting a Data Frame\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"datasets\")\nhead(airquality)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Ozone Solar.R Wind Temp Month Day\n1    41     190  7.4   67     5   1\n2    36     118  8.0   72     5   2\n3    12     149 12.6   74     5   3\n4    18     313 11.5   62     5   4\n5    NA      NA 14.3   56     5   5\n6    28      NA 14.9   66     5   6\n```\n\n\n:::\n:::\n\n\nWe can split the `airquality` data frame by the `Month` variable so that we have separate sub-data frames for each month.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ns <- split(airquality, airquality$Month)\nstr(s)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 5\n $ 5:'data.frame':\t31 obs. of  6 variables:\n  ..$ Ozone  : int [1:31] 41 36 12 18 NA 28 23 19 8 NA ...\n  ..$ Solar.R: int [1:31] 190 118 149 313 NA NA 299 99 19 194 ...\n  ..$ Wind   : num [1:31] 7.4 8 12.6 11.5 14.3 14.9 8.6 13.8 20.1 8.6 ...\n  ..$ Temp   : int [1:31] 67 72 74 62 56 66 65 59 61 69 ...\n  ..$ Month  : int [1:31] 5 5 5 5 5 5 5 5 5 5 ...\n  ..$ Day    : int [1:31] 1 2 3 4 5 6 7 8 9 10 ...\n $ 6:'data.frame':\t30 obs. of  6 variables:\n  ..$ Ozone  : int [1:30] NA NA NA NA NA NA 29 NA 71 39 ...\n  ..$ Solar.R: int [1:30] 286 287 242 186 220 264 127 273 291 323 ...\n  ..$ Wind   : num [1:30] 8.6 9.7 16.1 9.2 8.6 14.3 9.7 6.9 13.8 11.5 ...\n  ..$ Temp   : int [1:30] 78 74 67 84 85 79 82 87 90 87 ...\n  ..$ Month  : int [1:30] 6 6 6 6 6 6 6 6 6 6 ...\n  ..$ Day    : int [1:30] 1 2 3 4 5 6 7 8 9 10 ...\n $ 7:'data.frame':\t31 obs. of  6 variables:\n  ..$ Ozone  : int [1:31] 135 49 32 NA 64 40 77 97 97 85 ...\n  ..$ Solar.R: int [1:31] 269 248 236 101 175 314 276 267 272 175 ...\n  ..$ Wind   : num [1:31] 4.1 9.2 9.2 10.9 4.6 10.9 5.1 6.3 5.7 7.4 ...\n  ..$ Temp   : int [1:31] 84 85 81 84 83 83 88 92 92 89 ...\n  ..$ Month  : int [1:31] 7 7 7 7 7 7 7 7 7 7 ...\n  ..$ Day    : int [1:31] 1 2 3 4 5 6 7 8 9 10 ...\n $ 8:'data.frame':\t31 obs. of  6 variables:\n  ..$ Ozone  : int [1:31] 39 9 16 78 35 66 122 89 110 NA ...\n  ..$ Solar.R: int [1:31] 83 24 77 NA NA NA 255 229 207 222 ...\n  ..$ Wind   : num [1:31] 6.9 13.8 7.4 6.9 7.4 4.6 4 10.3 8 8.6 ...\n  ..$ Temp   : int [1:31] 81 81 82 86 85 87 89 90 90 92 ...\n  ..$ Month  : int [1:31] 8 8 8 8 8 8 8 8 8 8 ...\n  ..$ Day    : int [1:31] 1 2 3 4 5 6 7 8 9 10 ...\n $ 9:'data.frame':\t30 obs. of  6 variables:\n  ..$ Ozone  : int [1:30] 96 78 73 91 47 32 20 23 21 24 ...\n  ..$ Solar.R: int [1:30] 167 197 183 189 95 92 252 220 230 259 ...\n  ..$ Wind   : num [1:30] 6.9 5.1 2.8 4.6 7.4 15.5 10.9 10.3 10.9 9.7 ...\n  ..$ Temp   : int [1:30] 91 92 93 93 87 84 80 78 75 73 ...\n  ..$ Month  : int [1:30] 9 9 9 9 9 9 9 9 9 9 ...\n  ..$ Day    : int [1:30] 1 2 3 4 5 6 7 8 9 10 ...\n```\n\n\n:::\n:::\n\n\nThen we can take the column means for `Ozone`, `Solar.R`, and `Wind` for each sub-data frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlapply(s, function(x) {\n    colMeans(x[, c(\"Ozone\", \"Solar.R\", \"Wind\")])\n})\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$`5`\n   Ozone  Solar.R     Wind \n      NA       NA 11.62258 \n\n$`6`\n    Ozone   Solar.R      Wind \n       NA 190.16667  10.26667 \n\n$`7`\n     Ozone    Solar.R       Wind \n        NA 216.483871   8.941935 \n\n$`8`\n   Ozone  Solar.R     Wind \n      NA       NA 8.793548 \n\n$`9`\n   Ozone  Solar.R     Wind \n      NA 167.4333  10.1800 \n```\n\n\n:::\n:::\n\n\nUsing `sapply()` might be better here for a more readable output.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsapply(s, function(x) {\n    colMeans(x[, c(\"Ozone\", \"Solar.R\", \"Wind\")])\n})\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n               5         6          7        8        9\nOzone         NA        NA         NA       NA       NA\nSolar.R       NA 190.16667 216.483871       NA 167.4333\nWind    11.62258  10.26667   8.941935 8.793548  10.1800\n```\n\n\n:::\n:::\n\n\nUnfortunately, there are `NA`s in the data so we cannot simply take the means of those variables. However, we can tell the `colMeans` function to remove the `NA`s before computing the mean.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsapply(s, function(x) {\n    colMeans(x[, c(\"Ozone\", \"Solar.R\", \"Wind\")],\n        na.rm = TRUE\n    )\n})\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                5         6          7          8         9\nOzone    23.61538  29.44444  59.115385  59.961538  31.44828\nSolar.R 181.29630 190.16667 216.483871 171.857143 167.43333\nWind     11.62258  10.26667   8.941935   8.793548  10.18000\n```\n\n\n:::\n:::\n\n\nWe can also do this with `purrr` as shown below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npurrr::map(s, function(x) {\n    colMeans(x[, c(\"Ozone\", \"Solar.R\", \"Wind\")], na.rm = TRUE)\n})\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$`5`\n    Ozone   Solar.R      Wind \n 23.61538 181.29630  11.62258 \n\n$`6`\n    Ozone   Solar.R      Wind \n 29.44444 190.16667  10.26667 \n\n$`7`\n     Ozone    Solar.R       Wind \n 59.115385 216.483871   8.941935 \n\n$`8`\n     Ozone    Solar.R       Wind \n 59.961538 171.857143   8.793548 \n\n$`9`\n    Ozone   Solar.R      Wind \n 31.44828 167.43333  10.18000 \n```\n\n\n:::\n:::\n\n\nThe above is not as condensed as the `sapply()` output. We can use the *superseded* (aka no longer supported) function `map_dfc()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npurrr::map_dfc(s, function(x) {\n    colMeans(x[, c(\"Ozone\", \"Solar.R\", \"Wind\")], na.rm = TRUE)\n})\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 Ã— 5\n    `5`   `6`    `7`    `8`   `9`\n  <dbl> <dbl>  <dbl>  <dbl> <dbl>\n1  23.6  29.4  59.1   60.0   31.4\n2 181.  190.  216.   172.   167. \n3  11.6  10.3   8.94   8.79  10.2\n```\n\n\n:::\n:::\n\n\nOr use the currently supported function `purrr::list_cbind()`. Though we also need to do a bit more work behind the scenes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Make sure we get data.frame / tibble outputs for each element\n## of the list\npurrr:::map(s, function(x) {\n    tibble::as_tibble(colMeans(x[, c(\"Ozone\", \"Solar.R\", \"Wind\")], na.rm = TRUE))\n})\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$`5`\n# A tibble: 3 Ã— 1\n  value\n  <dbl>\n1  23.6\n2 181. \n3  11.6\n\n$`6`\n# A tibble: 3 Ã— 1\n  value\n  <dbl>\n1  29.4\n2 190. \n3  10.3\n\n$`7`\n# A tibble: 3 Ã— 1\n   value\n   <dbl>\n1  59.1 \n2 216.  \n3   8.94\n\n$`8`\n# A tibble: 3 Ã— 1\n   value\n   <dbl>\n1  60.0 \n2 172.  \n3   8.79\n\n$`9`\n# A tibble: 3 Ã— 1\n  value\n  <dbl>\n1  31.4\n2 167. \n3  10.2\n```\n\n\n:::\n\n```{.r .cell-code}\n## Now we can combine them with list_cbind()\npurrr:::map(s, function(x) {\n    tibble::as_tibble(colMeans(x[, c(\"Ozone\", \"Solar.R\", \"Wind\")], na.rm = TRUE))\n}) %>% purrr::list_cbind()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 Ã— 5\n  `5`$value `6`$value `7`$value `8`$value `9`$value\n      <dbl>     <dbl>     <dbl>     <dbl>     <dbl>\n1      23.6      29.4     59.1      60.0       31.4\n2     181.      190.     216.      172.       167. \n3      11.6      10.3      8.94      8.79      10.2\n```\n\n\n:::\n\n```{.r .cell-code}\n## And we can then add the actual variable it came from with mutate()\npurrr:::map(s, function(x) {\n    tibble::as_tibble(colMeans(x[, c(\"Ozone\", \"Solar.R\", \"Wind\")], na.rm = TRUE))\n}) %>%\n    purrr::list_cbind() %>%\n    dplyr::mutate(Variable = c(\"Ozone\", \"Solar.R\", \"Wind\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 Ã— 6\n  `5`$value `6`$value `7`$value `8`$value `9`$value Variable\n      <dbl>     <dbl>     <dbl>     <dbl>     <dbl> <chr>   \n1      23.6      29.4     59.1      60.0       31.4 Ozone   \n2     181.      190.     216.      172.       167.  Solar.R \n3      11.6      10.3      8.94      8.79      10.2 Wind    \n```\n\n\n:::\n:::\n\n\nAs we know, the above output is not *tidy*.\n\n[![](https://cdn.myportfolio.com/45214904-6a61-4e23-98d6-b140f8654a40/6e297111-efb7-4555-93d2-085071d1853c_rw_1920.jpg?h=f1951b118eaddaaab8a572422bc16566){fig-align=\"center\"}](https://allisonhorst.com/other-r-fun)\n\nSo below we repeat the steps using similar functions. First we use the superseded `map_dfr()` function. At <https://purrr.tidyverse.org/reference/map_dfr.html> we can find more details about why this function was superseded and what that means.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Sadly map_dfr() is now superseded (aka not recommended)\npurrr:::map_dfr(s, function(x) {\n    colMeans(x[, c(\"Ozone\", \"Solar.R\", \"Wind\")], na.rm = TRUE)\n})\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 Ã— 3\n  Ozone Solar.R  Wind\n  <dbl>   <dbl> <dbl>\n1  23.6    181. 11.6 \n2  29.4    190. 10.3 \n3  59.1    216.  8.94\n4  60.0    172.  8.79\n5  31.4    167. 10.2 \n```\n\n\n:::\n\n```{.r .cell-code}\n## This is how we would have added back the Month variable\npurrr:::map_dfr(s, function(x) {\n    colMeans(x[, c(\"Ozone\", \"Solar.R\", \"Wind\")], na.rm = TRUE)\n}) %>%\n    dplyr:::mutate(Month = as.integer(names(s)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 Ã— 4\n  Ozone Solar.R  Wind Month\n  <dbl>   <dbl> <dbl> <int>\n1  23.6    181. 11.6      5\n2  29.4    190. 10.3      6\n3  59.1    216.  8.94     7\n4  60.0    172.  8.79     8\n5  31.4    167. 10.2      9\n```\n\n\n:::\n:::\n\n\nInstead, we'll use the `t()` function for transposing a vector and `purrr:list_rbind()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Get data.frame / tibble outputs, but with each variable as a separate\n## column. Here we used the t() or transpose() function.\npurrr:::map(s, function(x) {\n    tibble::as_tibble(t(colMeans(x[, c(\"Ozone\", \"Solar.R\", \"Wind\")], na.rm = TRUE)))\n})\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$`5`\n# A tibble: 1 Ã— 3\n  Ozone Solar.R  Wind\n  <dbl>   <dbl> <dbl>\n1  23.6    181.  11.6\n\n$`6`\n# A tibble: 1 Ã— 3\n  Ozone Solar.R  Wind\n  <dbl>   <dbl> <dbl>\n1  29.4    190.  10.3\n\n$`7`\n# A tibble: 1 Ã— 3\n  Ozone Solar.R  Wind\n  <dbl>   <dbl> <dbl>\n1  59.1    216.  8.94\n\n$`8`\n# A tibble: 1 Ã— 3\n  Ozone Solar.R  Wind\n  <dbl>   <dbl> <dbl>\n1  60.0    172.  8.79\n\n$`9`\n# A tibble: 1 Ã— 3\n  Ozone Solar.R  Wind\n  <dbl>   <dbl> <dbl>\n1  31.4    167.  10.2\n```\n\n\n:::\n\n```{.r .cell-code}\n## Now we can row bind each of these data.frames / tibbles into a\n## single one\npurrr:::map(s, function(x) {\n    tibble::as_tibble(t(colMeans(x[, c(\"Ozone\", \"Solar.R\", \"Wind\")], na.rm = TRUE)))\n}) %>% purrr::list_rbind()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 Ã— 3\n  Ozone Solar.R  Wind\n  <dbl>   <dbl> <dbl>\n1  23.6    181. 11.6 \n2  29.4    190. 10.3 \n3  59.1    216.  8.94\n4  60.0    172.  8.79\n5  31.4    167. 10.2 \n```\n\n\n:::\n\n```{.r .cell-code}\n## Then with mutate, we can add the Month back\npurrr:::map(s, function(x) {\n    tibble::as_tibble(t(colMeans(x[, c(\"Ozone\", \"Solar.R\", \"Wind\")], na.rm = TRUE)))\n}) %>%\n    purrr::list_rbind() %>%\n    dplyr:::mutate(Month = as.integer(names(s)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 Ã— 4\n  Ozone Solar.R  Wind Month\n  <dbl>   <dbl> <dbl> <int>\n1  23.6    181. 11.6      5\n2  29.4    190. 10.3      6\n3  59.1    216.  8.94     7\n4  60.0    172.  8.79     8\n5  31.4    167. 10.2      9\n```\n\n\n:::\n:::\n\n\nFor the above task though, we might prefer to use `dplyr` functions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## group_by() is in a way splitting our input data.frame / tibble by\n## our variable of interest. Then summarize() helps us specify how we\n## want to use that data, before it's all put back together into a\n## tidy tibble.\nairquality %>%\n    dplyr::group_by(Month) %>%\n    dplyr::summarize(\n        Ozone = mean(Ozone, na.rm = TRUE),\n        Solar.R = mean(Solar.R, na.rm = TRUE),\n        Wind = mean(Wind, na.rm = TRUE)\n    )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 Ã— 4\n  Month Ozone Solar.R  Wind\n  <int> <dbl>   <dbl> <dbl>\n1     5  23.6    181. 11.6 \n2     6  29.4    190. 10.3 \n3     7  59.1    216.  8.94\n4     8  60.0    172.  8.79\n5     9  31.4    167. 10.2 \n```\n\n\n:::\n:::\n\n\n## tapply\n\n`tapply()` is used to apply a function over subsets of a vector. It can be thought of as a combination of `split()` and `sapply()` for vectors only. I've been told that the \"t\" in `tapply()` refers to \"table\", but that is unconfirmed.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(tapply)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfunction (X, INDEX, FUN = NULL, ..., default = NA, simplify = TRUE)  \n```\n\n\n:::\n:::\n\n\nThe arguments to `tapply()` are as follows:\n\n-   `X` is a vector\n-   `INDEX` is a factor or a list of factors (or else they are coerced to factors)\n-   `FUN` is a function to be applied\n-   ... contains other arguments to be passed `FUN`\n-   `simplify`, should we simplify the result?\n\n::: callout-tip\n### Example\n\nGiven a vector of numbers, one simple operation is to take group means.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Simulate some data\nx <- c(rnorm(10), runif(10), rnorm(10, 1))\n## Define some groups with a factor variable\nf <- gl(3, 10)\nf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3\nLevels: 1 2 3\n```\n\n\n:::\n\n```{.r .cell-code}\ntapply(x, f, mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n          1           2           3 \n0.008496425 0.434576502 1.051060161 \n```\n\n\n:::\n:::\n\n:::\n\nWe can also apply functions that return more than a single value. In this case, `tapply()` will not simplify the result and will return a list. Here's an example of finding the `range()` (min and max) of each sub-group.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntapply(x, f, range)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$`1`\n[1] -1.35972  1.39826\n\n$`2`\n[1] 0.08806992 0.92058272\n\n$`3`\n[1] -0.1887393  3.0773427\n```\n\n\n:::\n:::\n\n\nWith `purrr`, we don't have a `tapply()` direct equivalent but we can still get similar results thanks to the `split()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsplit(x, f) %>% purrr::map_dbl(mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n          1           2           3 \n0.008496425 0.434576502 1.051060161 \n```\n\n\n:::\n\n```{.r .cell-code}\nsplit(x, f) %>% purrr::map(range)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$`1`\n[1] -1.35972  1.39826\n\n$`2`\n[1] 0.08806992 0.92058272\n\n$`3`\n[1] -0.1887393  3.0773427\n```\n\n\n:::\n:::\n\n\n## `apply()`\n\nThe `apply()` function is used to a evaluate a function (often an anonymous one) over the margins of an array. It is most often used to apply a function to the rows or columns of a matrix (which is just a 2-dimensional array). However, it can be used with general arrays, for example, to take the average of an array of matrices. Using `apply()` is not really faster than writing a loop, but it works in one line and is highly compact.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(apply)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfunction (X, MARGIN, FUN, ..., simplify = TRUE)  \n```\n\n\n:::\n:::\n\n\nThe arguments to `apply()` are\n\n-   `X` is an array\n-   `MARGIN` is an integer vector indicating which margins should be \"retained\".\n-   `FUN` is a function to be applied\n-   `...` is for other arguments to be passed to `FUN`\n\n::: callout-tip\n### Example\n\nHere I create a 20 by 10 matrix of Normal random numbers. I then compute the mean of each column.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- matrix(rnorm(200), 20, 10)\nhead(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n            [,1]        [,2]       [,3]      [,4]       [,5]       [,6]\n[1,]  0.50046809  0.01319246 -1.2257339 0.6534950  2.0240798 -0.5110592\n[2,] -0.97947352 -0.74034878 -0.7333293 0.0852587  0.9646342  1.0375407\n[3,] -0.76175904 -0.78276570 -1.3256824 0.5074134 -0.5256627 -1.8718745\n[4,] -0.05374418  1.40241236 -1.1572989 0.4923247  1.1692155  1.2495283\n[5,]  0.21665370  2.49795506  1.0303902 0.1020464  0.7384473  0.6245013\n[6,]  0.21451380 -1.58611504 -0.3422167 0.5026345 -1.0660648  0.2152146\n           [,7]       [,8]       [,9]       [,10]\n[1,]  3.0450395  0.4156979 -1.5711215  1.16470122\n[2,] -1.1407109 -1.3683067 -0.8307222 -0.01687646\n[3,] -0.9718256  0.6301801  0.2372567  0.27668133\n[4,]  0.8450216 -1.2188740 -0.7058502 -0.65473690\n[5,]  0.7673133  0.3547224  1.3843766 -0.84345422\n[6,]  0.6824437  0.3520303  0.5901982 -0.52446529\n```\n\n\n:::\n\n```{.r .cell-code}\napply(x, 2, mean) ## Take the mean of each column\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] -0.01626919  0.10659913 -0.31981647  0.09469021  0.30397538 -0.16036582\n [7]  0.39368026 -0.13370231 -0.12090136  0.04522372\n```\n\n\n:::\n:::\n\n:::\n\n::: callout-tip\n### Example\n\nI can also compute the sum of each row.\n\n\n::: {.cell}\n\n```{.r .cell-code}\napply(x, 1, sum) ## Take the mean of each row\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  4.5087595 -3.7223342 -4.5880384  1.3679983  6.8729520 -0.9618265\n [7]  0.3539245  3.6576807  2.3910655 -1.8471082  1.9953436 -6.0260360\n[13] -6.2214171 -0.1334884 -0.9813945  0.6822732  5.7145910 -3.5023396\n[19]  5.2571158 -0.9554501\n```\n\n\n:::\n:::\n\n:::\n\n::: callout-tip\n### Note\n\nIn both calls to `apply()`, the return value was a vector of numbers.\n:::\n\nYou've probably noticed that the second argument is either a 1 or a 2, depending on whether we want row statistics or column statistics. What exactly *is* the second argument to `apply()`?\n\nThe `MARGIN` argument essentially indicates to `apply()` which dimension of the array you want to preserve or retain.\n\nSo when taking the mean of each column, I specify\n\n\n::: {.cell}\n\n```{.r .cell-code}\napply(x, 2, mean)\n```\n:::\n\n\nbecause I want to collapse the first dimension (the rows) by taking the mean and I want to preserve the number of columns. Similarly, when I want the row sums, I run\n\n\n::: {.cell}\n\n```{.r .cell-code}\napply(x, 1, sum)\n```\n:::\n\n\nbecause I want to collapse the columns (the second dimension) and preserve the number of rows (the first dimension).\n\nWith `purrr` this is a bit more complicated as it has been generalized. Matrices are arrays with 2 dimensions (margins), but they can have more. Here we use the `array_branch()` function to change `x` into a list, then use regular `map_*()` functions to compute what we want.\n\n\n::: {.cell}\n\n```{.r .cell-code}\narray_branch(x, 2) %>% map_dbl(mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] -0.01626919  0.10659913 -0.31981647  0.09469021  0.30397538 -0.16036582\n [7]  0.39368026 -0.13370231 -0.12090136  0.04522372\n```\n\n\n:::\n\n```{.r .cell-code}\narray_branch(x, 1) %>% map_dbl(sum)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  4.5087595 -3.7223342 -4.5880384  1.3679983  6.8729520 -0.9618265\n [7]  0.3539245  3.6576807  2.3910655 -1.8471082  1.9953436 -6.0260360\n[13] -6.2214171 -0.1334884 -0.9813945  0.6822732  5.7145910 -3.5023396\n[19]  5.2571158 -0.9554501\n```\n\n\n:::\n:::\n\n\n### Col/Row Sums and Means\n\n::: callout-tip\n### Pro-tip\n\nFor the special case of column/row sums and column/row means of matrices, we have some useful shortcuts.\n\n-   `rowSums` = `apply(x, 1, sum)`\n-   `rowMeans` = `apply(x, 1, mean)`\n-   `colSums` = `apply(x, 2, sum)`\n-   `colMeans` = `apply(x, 2, mean)`\n:::\n\nThe shortcut functions are heavily optimized and hence are **much** faster, but you probably won't notice unless you're using a large matrix.\n\nAnother nice aspect of these functions is that they are a bit more descriptive. It's arguably more clear to write `colMeans(x)` in your code than `apply(x, 2, mean)`.\n\n### Other Ways to Apply\n\nYou can do more than take sums and means with the `apply()` function.\n\n::: callout-tip\n### Example\n\nFor example, you can compute quantiles of the rows of a matrix using the `quantile()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- matrix(rnorm(200), 20, 10)\nhead(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           [,1]       [,2]       [,3]       [,4]       [,5]        [,6]\n[1,]  0.8558389  1.2785114 -1.1288694  0.3338215  1.6094488 -0.22610146\n[2,] -0.2651168  0.9989627 -0.9657882 -0.2079840  2.8384617 -0.07137058\n[3,] -0.1270123  0.2804062  0.2954063 -0.6753049  1.6021894 -0.04851862\n[4,]  0.3901520 -0.3279092 -0.2545932  0.7519181  1.4313260 -1.87021854\n[5,]  0.1027492 -0.2221477 -0.2716407  0.6181248 -1.1347917  0.66075218\n[6,] -0.6223277  0.5674514  0.2159777 -0.3270915 -0.2631378 -0.02378593\n           [,7]         [,8]       [,9]      [,10]\n[1,]  0.2544274 -0.192036937 -0.6799559  0.6865429\n[2,] -0.3435362 -0.005259005 -0.6227724 -2.0137902\n[3,]  1.1365090 -0.774514378  0.2140942  0.3998026\n[4,]  0.2192841 -0.291010481  1.0355954 -1.2352538\n[5,]  0.3817243 -0.968810389  0.3682024 -1.9738577\n[6,] -0.3255215 -1.031961178 -1.1926808 -0.5793324\n```\n\n\n:::\n\n```{.r .cell-code}\n## Get row quantiles\napply(x, 1, quantile, probs = c(0.25, 0.75))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n          [,1]       [,2]       [,3]       [,4]       [,5]       [,6]      [,7]\n25% -0.2175853 -0.5529634 -0.1073889 -0.3186845 -0.7945180 -0.6115789 -1.222741\n75%  0.8135149 -0.0217869  0.3737035  0.6614765  0.3783438 -0.0836239  1.109337\n          [,8]       [,9]      [,10]       [,11]      [,12]        [,13]\n25% -0.6131110 -0.7269225 0.01274949 -0.06737453 -0.6219057 -0.948169094\n75%  0.4474504  0.4613348 0.41963659  1.18111557  0.3751943  0.006215612\n         [,14]      [,15]      [,16]      [,17]      [,18]      [,19]\n25% -0.1027043 -1.4287004 -0.2514263 -0.7535182 -0.7057536 -0.2993755\n75%  0.6071806  0.2703042  0.4057326  0.1918586  0.2537656  0.2507634\n         [,20]\n25% -0.5239071\n75%  0.5436785\n```\n\n\n:::\n:::\n\n\nNotice that I had to pass the `probs = c(0.25, 0.75)` argument to `quantile()` via the `...` argument to `apply()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\narray_branch(x, 1) %>%\n    map(quantile, probs = c(0.25, 0.75)) %>%\n    map(~ as.data.frame(t(.x))) %>%\n    list_rbind()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           25%          75%\n1  -0.21758533  0.813514883\n2  -0.55296337 -0.021786899\n3  -0.10738885  0.373703518\n4  -0.31868455  0.661476538\n5  -0.79451797  0.378343841\n6  -0.61157890 -0.083623902\n7  -1.22274071  1.109337157\n8  -0.61311097  0.447450354\n9  -0.72692253  0.461334754\n10  0.01274949  0.419636588\n11 -0.06737453  1.181115568\n12 -0.62190573  0.375194348\n13 -0.94816909  0.006215612\n14 -0.10270429  0.607180553\n15 -1.42870045  0.270304169\n16 -0.25142633  0.405732633\n17 -0.75351818  0.191858582\n18 -0.70575359  0.253765591\n19 -0.29937550  0.250763397\n20 -0.52390708  0.543678487\n```\n\n\n:::\n:::\n\n:::\n\n## Vectorizing a Function\n\nLet's talk about how we can **\"vectorize\" a function**.\n\nWhat this means is that we can write function that typically only takes single arguments and create a new function that can take vector arguments.\n\nThis is often needed when you want to plot functions.\n\n::: callout-tip\n### Example\n\nHere's an example of a function that computes the sum of squares given some data, a mean parameter and a standard deviation. The formula is $\\sum_{i=1}^n(x_i-\\mu)^2/\\sigma^2$.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsumsq <- function(mu, sigma, x) {\n    sum(((x - mu) / sigma)^2)\n}\n```\n:::\n\n\nThis function takes a mean `mu`, a standard deviation `sigma`, and some data in a vector `x`.\n\nIn many statistical applications, we want to minimize the sum of squares to find the optimal `mu` and `sigma`. Before we do that, we may want to evaluate or plot the function for many different values of `mu` or `sigma`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- rnorm(100) ## Generate some data\nsumsq(mu = 1, sigma = 1, x) ## This works (returns one value)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 222.3181\n```\n\n\n:::\n:::\n\n\nHowever, passing a vector of `mu`s or `sigma`s won't work with this function because it's not vectorized.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsumsq(1:10, 1:10, x) ## This is not what we want\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 108.6111\n```\n\n\n:::\n:::\n\n:::\n\nThere's even a function in R called `Vectorize()` that **automatically can create a vectorized version of your function**.\n\nSo we could create a `vsumsq()` function that is fully vectorized as follows.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvsumsq <- Vectorize(sumsq, c(\"mu\", \"sigma\"))\nvsumsq(1:10, 1:10, x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 222.3181 135.4636 117.9323 111.3079 108.0185 106.1111 104.8885 104.0480\n [9] 103.4396 102.9814\n```\n\n\n:::\n\n```{.r .cell-code}\n## The details are a bit complicated though\n## as we can see below\nvsumsq\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfunction (mu, sigma, x) \n{\n    args <- lapply(as.list(match.call())[-1L], eval, parent.frame())\n    names <- names(args) %||% character(length(args))\n    dovec <- names %in% vectorize.args\n    do.call(\"mapply\", c(FUN = FUN, args[dovec], MoreArgs = list(args[!dovec]), \n        SIMPLIFY = SIMPLIFY, USE.NAMES = USE.NAMES))\n}\n<environment: 0x1284014f8>\n```\n\n\n:::\n:::\n\n\nPretty cool, right?\n\n# Parallelize your functions\n\nWe don't have time to dive into the details, but with `furrr` we can parallelize `purrr` functions thanks to the `future` package. More details at <https://furrr.futureverse.org/>.\n\nSimilarly, with `BiocParallel::bplapply()` we can parallelize `lapply()` commands. Details at <https://bioconductor.org/packages/release/bioc/vignettes/BiocParallel/inst/doc/Introduction_To_BiocParallel.html> and more generally at <https://bioconductor.org/packages/BiocParallel/>.\n\n# Summary\n\n-   The loop functions in R are very powerful because they allow you to conduct a series of operations on data using a compact form\n\n-   The operation of a loop function involves iterating over an R object (e.g. a list or vector or matrix), applying a function to each element of the object, and the collating the results and returning the collated results.\n\n-   Loop functions make heavy use of anonymous functions, which exist for the life of the loop function but are not stored anywhere\n\n-   The `split()` function can be used to divide an R object in to subsets determined by another variable which can subsequently be looped over using loop functions.\n\n-   With `purrr` you have very tight control on the expected output, unlike with base R.\n\n# Post-lecture materials\n\n### Final Questions\n\nHere are some post-lecture questions to help you think about the material discussed.\n\n::: callout-note\n### Questions\n\n1.  Write a function `compute_s_n()` that for any given `n` computes the sum\n\n$$\nS_n = 1^2 + 2^2 + 3^2 + \\ldots + n^2\n$$\n\nReport the value of the sum when $n$ = 10.\n\n2.  Define an empty numerical vector `s_n` of size 25 using `s_n <- vector(\"numeric\", 25)` and store in the results of $S_1, S_2, \\ldots, S_n$ using a for-loop.\n\n3.  Repeat Q3, but this time use `sapply() or functions from`purrr`.`\n\n4.  Plot `s_n` versus `n`. Use points defined by $n= 1, \\ldots, 25$\n:::\n\n### Additional Resources\n\n::: callout-tip\n-   <https://rdpeng.github.io/Biostat776/lecture-loop-functions>\n-   <https://rafalab.github.io/dsbook/programming-basics.html#vectorization>\n:::\n\n# R session information\n\n\n::: {.cell}\n\n```{.r .cell-code}\noptions(width = 120)\nsessioninfo::session_info()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nâ”€ Session info â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n setting  value\n version  R version 4.5.1 (2025-06-13)\n os       macOS Sequoia 15.6.1\n system   aarch64, darwin20\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       America/New_York\n date     2025-09-22\n pandoc   3.7.0.2 @ /opt/homebrew/bin/ (via rmarkdown)\n quarto   1.4.550 @ /Applications/quarto/bin/quarto\n\nâ”€ Packages â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n package     * version date (UTC) lib source\n brio          1.1.5   2024-04-24 [1] CRAN (R 4.5.0)\n cli           3.6.5   2025-04-23 [1] CRAN (R 4.5.0)\n colorout    * 1.3-2   2025-05-09 [1] Github (jalvesaq/colorout@572ab10)\n desc          1.4.3   2023-12-10 [1] CRAN (R 4.5.0)\n digest        0.6.37  2024-08-19 [1] CRAN (R 4.5.0)\n dplyr         1.1.4   2023-11-17 [1] CRAN (R 4.5.0)\n evaluate      1.0.5   2025-08-27 [1] CRAN (R 4.5.0)\n fastmap       1.2.0   2024-05-15 [1] CRAN (R 4.5.0)\n generics      0.1.4   2025-05-09 [1] CRAN (R 4.5.0)\n glue          1.8.0   2024-09-30 [1] CRAN (R 4.5.0)\n htmltools     0.5.8.1 2024-04-04 [1] CRAN (R 4.5.0)\n htmlwidgets   1.6.4   2023-12-06 [1] CRAN (R 4.5.0)\n jsonlite      2.0.0   2025-03-27 [1] CRAN (R 4.5.0)\n knitr         1.50    2025-03-16 [1] CRAN (R 4.5.0)\n lifecycle     1.0.4   2023-11-07 [1] CRAN (R 4.5.0)\n magrittr      2.0.4   2025-09-12 [1] CRAN (R 4.5.0)\n pillar        1.11.1  2025-09-17 [1] CRAN (R 4.5.0)\n pkgconfig     2.0.3   2019-09-22 [1] CRAN (R 4.5.0)\n pkgload       1.4.0   2024-06-28 [1] CRAN (R 4.5.0)\n purrr       * 1.1.0   2025-07-10 [1] CRAN (R 4.5.0)\n R6            2.6.1   2025-02-15 [1] CRAN (R 4.5.0)\n rlang         1.1.6   2025-04-11 [1] CRAN (R 4.5.0)\n rmarkdown     2.29    2024-11-04 [1] CRAN (R 4.5.0)\n rprojroot     2.1.1   2025-08-26 [1] CRAN (R 4.5.0)\n sessioninfo   1.2.3   2025-02-05 [1] CRAN (R 4.5.0)\n sum776        0.99.0  2025-09-22 [1] Github (lcolladotor/sum776@fa92a67)\n testthat    * 3.2.3   2025-01-13 [1] CRAN (R 4.5.0)\n tibble        3.3.0   2025-06-08 [1] CRAN (R 4.5.0)\n tidyselect    1.2.1   2024-03-11 [1] CRAN (R 4.5.0)\n utf8          1.2.6   2025-06-08 [1] CRAN (R 4.5.0)\n vctrs         0.6.5   2023-12-01 [1] CRAN (R 4.5.0)\n waldo         0.6.2   2025-07-11 [1] CRAN (R 4.5.0)\n withr         3.0.2   2024-10-28 [1] CRAN (R 4.5.0)\n xfun          0.53    2025-08-19 [1] CRAN (R 4.5.0)\n yaml          2.3.10  2024-07-26 [1] CRAN (R 4.5.0)\n\n [1] /Library/Frameworks/R.framework/Versions/4.5-arm64/Resources/library\n * â”€â”€ Packages attached to the search path.\n\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}